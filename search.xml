<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSP基础]]></title>
    <url>%2F2018%2F09%2F14%2FJavaWeb%2FJSP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Web应用程序：通过Web访问的应用程序，如淘宝网等。 JavaWeb基础与JSP软件开发三大方向： 桌面应用程序：QQ、Office等 Web应用程序：淘宝、京东等 嵌入式应用程序：安卓、iPhone上的应用程序等 JavaWeb开发属于Java EE方向。 JSP：Java Server Pages，Java服务器端页面，一个简化的Servlet设计，实现了在Java中使用HTML标签。JSP本质上是一种动态网页技术标准，属于Java EE标准。JSP与Servlet一样，也是在服务器端执行的。 静态网页：网页中内容固定，不会更新。需要HTML、CSS等技术即可。 动态网页：网页中内容通过程序动态显示，自动更新。需要HTML、CSS、数据库、一门高级语言(Java、C#、PHP)、客户端脚本知识JavaScript、XML等技术。 主流的动态网页脚本技术： JSP：Java平台，安全性高、跨平台性好，适于开发大型的、企业级的、分布式的Web应用程序。如分布式计算框架Hadoop等。 Asp.net：微软的.net平台，简单易学，但安全性和跨平台性差。 PHP：简单高效，成本低，开发周期短，适合中小型企业的Web应用开发。常用组合LAMP：Linux + Apache(阿帕奇服务器) + MySQL + PHP。 动态网页的动态指的是能与用户进行交互，如登录时输入正确的用户名与密码，系统会提示登录成功。 TomcatTomcat服务器： Apache Jakarta的开源项目 常见的JavaWeb容器，能解析HTML、CSS、JavaScript等常见的标签语言。 JSP、Servlet的容器 Tomcat的目录结构： WEB-INF目录结构： WEB-INF是Java的WEB应用的安全目录。即客户端无法访问，只有服务端可以访问的目录。 web.xml为项目部署文件。 classes文件夹用于放置*.class文件。 lib文件夹用于存放需要的jar包。 JSP页面组成部分JSP指令page：位于JSP页面顶端，同样页面可以有多个page指令 ISO-8859-1不支持中文，建议换成UTF-8 include：将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。 taglib：使用标签库定义新的自定义标签，在JSP页面中启用定制行为。 JSP注释 客户端可见意思是查看网页源代码时可以看到。 JSP脚本注释客户端不可见。 JSP脚本在JSP页面中执行Java代码。 &lt;% java 代码 %&gt; JSP声明在JSP页面中定义变量或方法。 &lt;%! java代码 %&gt; JSP表达式在JSP界面中执行的表达式 &lt;%= java表达式 %&gt; 不能以分号结尾。 JSP页面的生命周期 第一次请求一个JSP页面时，首先被执行的是静态方法。 jspService()方法被调用来处理客户端的请求。对每一个请求，JSP引擎创建一个新的线程来处理该请求。JSP与Servlet始终驻于内存，故响应时间快。 JSP页面内容发生改变后，需要重新编译。 JSP九大内置对象JSP内置对象是Web容器创建的一组对象，不使用new关键字就可以使用。 Web程序的请求响应模式 用户发送HTTP请求。(request) 服务器给用户HTTP响应。(respose) 缓冲区：Buffer，内存中一块用来保存临时数据的区域。 表单有两种提交方式表单： get：以明文方式通过URL提交数据，数据在URL中可以看到，最多不超过2KB，安全性低效率高，适合提交数据量小且对安全性要求不高的数据，如搜索、查询等功能。 post：将用户提交的信息封装在HTML HEADER内，适合提交数量大、安全性高的用户信息，如注册、修改、上传等。 请求重定向与请求转发 请求重定向：客户端行为，response.sendRedirect(java.lang.String location)，括号内为要重定向的地址。从本质上来看等同于两次请求，前一次请求对象并不会被保存，地址栏的URL地址会改变。 请求转发：服务器行为，request.getRequestDispatcher(java.lang.String location).forward(request,response)，括号内为要转发的地址。从本质上来看是一次请求，转发后请求对象会被保存，地址栏的URL地址不会改变。 outJspWriter类的实例，向客户端输出内容的常用对象。 clear()若抛出异常，则程序立即终止运行，后面的语句不会执行。clearBuffer()不会抛出异常，后面的语句依旧执行。 requestHttpServletRequest类的实例，客户端的请求信息被封装在request对象中，通过它才能了解客户的请求，然后做出相应。request对象具有请求域，即完成客户端的请求之前该对象一直有效。 responseresponse对象包含了响应客户请求的有关信息，但在JSP中很少直接使用它。它是HttpServletResponse类的实例。response对象具有页面作用域，即访问一个页面时该页面内的response对象只能对这次访问有效，其它页面的response对象对当前页面无效。 PrintWriter对象的输出总是提前于内置out对象。 可以用out.flush()强制out对象的输出在PrintWriter对象的前面。 sessionHttpSession类的实例，表示客户端与服务器的一次会话。Web中的session指的是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。特定的时间概念 在服务器的内存中保存着不同用户的session，每个用户都有不同的session。 session对象在第一个JSP页面被装载时自动创建，完成后会活期管理。 从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。 当一个客户访问一个服务器时，可能会在服务器几个页面间切换，服务器用session对象知道这是一个客户。 session对象的生命周期： 创建：当客户端第一次访问某个JSP或Servlet时，服务器会为当前会话创建一个session ID，每次客户端向服务器端发送请求时，都会将此session ID携带过去，服务端会对此session ID进行校验。 活动： 某次会话当中通过超链接打开的新页面属于同一次会话。 只要当前会话页面没有全部关闭，重新打开新的浏览器窗口访问同一项目是属于同一次会话。 除非本次会话的所有页面都关闭后再重新访问，某个JSP或Servlet将会创建新的会话。原有会话还存在，旧的session ID仍存在于服务器端，只不过再也没有客户端会携带它然后交给服务器端校验。 销毁(只有三种方式)： 调用了session.invalidate()方法 session过期(超时)默认为30分钟 服务器重新启动 设置超时时间的方式： session.setMaxInactiveInternal(…) 单位为s 在web.xml中配置 123456789&lt;session-config&gt; &lt;session-timeout&gt; 10 &lt;session-timeout&gt;&lt;session-config&gt; ​ 单位为min。 application 实现了用户间数据的共享，可存放全局变量 开始于服务器启动，终止于服务器关闭 在用户的前后连接或不同的用户间的连接中，可以对application对象的同一属性进行操作。 在任何地方对application对象属性的操作，都会影响到其他用户对它的访问。 ServletContext类的实例。 page pageContext config exception]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[其他]]></title>
    <url>%2F2018%2F09%2F09%2FMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[视图、存储过程、游标、触发器]]></title>
    <url>%2F2018%2F09%2F09%2FMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E6%B8%B8%E6%A0%87%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用语句]]></title>
    <url>%2F2018%2F09%2F09%2FMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2FMySQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[关键字：作为MySQL语言组成部分的一个保留字，不要用关键字命名一个表或者一个列。 SHOW语句123456789101112131415161718192021-- 使用carshcourse数据库USE carshcourse;-- 显示可用的数据库列表SHOW DATABASES;-- 显示一个数据库内的表的列表SHOW TABLES;-- 显示customers表的表列，对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、是否为主键/外键、默认值以及其他信息SHOW COLUMNS FROM customers;-- 上述代码的简写DESCRIBE customers;-- 显示服务器错误或警告信息SHOW ERROWS;SHOW WARNINGS;-- 显示用户的安全权限SHOW GRANTS; 自动增量：在每个行添加到表中时，MySQ可以自动为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值。 SELECT语句123456789101112131415161718SELECT prod_name from products;SELECT * FROM products;-- 检索不同的行SELECT DISTINCT vend_id FROM products;-- 返回不多于5行SELECT prod_name FROM products LIMIT 5;-- 以第一个数为开始位置，返回不多于第二个数的行数(第一行为行0)SELECT prod_name FROM products LIMIT 5,6;-- 上述代码的替代语法SELECT prod_name FROM products LIMIT 6 OFFSET 5;-- 使用完全限定的表名SELECT products.prod_name FROM crashcourse.products;]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2018%2F09%2F09%2FMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库：保存有组织的数据的容器。 基础知识(1-2章)无法直接访问数据库，必须使用MySQL等数据库管理系统(DBMS)来创建与操纵数据库。 表：某种特定类型数据的结构化清单。(一种类型的数据) 相同数据库中不能两次使用相同的表名。 模式：关于数据库和表的布局及特性的信息。如可以存储什么样的数据、数据如何分解、各部分信息如何命名等，描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库(和其中的表的关系)。 列：表中的一个字段。所有表都是由一个或多个列组成的。 行：表中的一个记录。表中的数据按行存储，所保存的每个记录存储在自己的行内。 主键：一列或一组列，其值能够唯一区分表中每个行。 任意两行都不具有相同的主键值 每个行都必须具有一个主键值(不允许NULL值) 好习惯: 不更新主键列中的值 不重用主键列的值 不在主键列中使用可能会更改的值 SQL：结构化查询语言，一种专门用来与数据库通信的语言 不是某个特定数据库的专利语言，任意两个DBMS实现的SQL都不完全相同。 DBMS分两类： 基于共享文件系统的DBMS，用于桌面用途，通常不用于高端或更关键的应用。(如Microsoft Access和FileMaker) 基于客户机-服务器的DBMS，服务器部分负责所有数据的访问和处理，运行在数据库服务器上，与数据打交道的只有服务器软件，客户机是与用户打交道的软件。(如MySQL、Oracle、Microsoft SQL Server等) 客户机与服务器软件可以安装在一台或者多台计算机上，用户不能直接访问数据文件。 数据类型(附录D)数据类型：一个列中所容许的数据的类型。 每个表列都有相应的数据类型，它限制该列中存储的数据。 数据类型允许在内部更有效地存储数据。如可以用一种比文本串更简洁的格式存储数值和日期时间值。 数据类型允许变换排序顺序。如1、10、2作为串处理和作为数值处理排序不同。 串数据类型定长串：接受固定长度的字符串，长度在创建表时指定。如CHAR 变长串：存储可变长度的文本。如TEXT 变长串更灵活，但处理时间长且不可被索引；定长串处理速度快且可被索引。 串必须括在引号内，最好是单引号。 数值数据类型 使用UNSIGNED关键字后只能存储正数，取值范围翻倍。 数值不应该括在引号内。 MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8,2)。 日期与时间数据类型 二进制数据类型 二进制数据类型可以存储任何数据(甚至包括二进制信息)，如图像、多媒体、字处理文档等。 MySQL必知必会中使用的数据库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091######################### Create customers table########################CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL , cust_address char(50) NULL , cust_city char(50) NULL , cust_state char(5) NULL , cust_zip char(10) NULL , cust_country char(50) NULL , cust_contact char(50) NULL , cust_email char(255) NULL , PRIMARY KEY (cust_id)) ENGINE=InnoDB;########################## Create orderitems table#########################CREATE TABLE orderitems( order_num int NOT NULL , order_item int NOT NULL , prod_id char(10) NOT NULL , quantity int NOT NULL , item_price decimal(8,2) NOT NULL , PRIMARY KEY (order_num, order_item)) ENGINE=InnoDB;###################### Create orders table#####################CREATE TABLE orders( order_num int NOT NULL AUTO_INCREMENT, order_date datetime NOT NULL , cust_id int NOT NULL , PRIMARY KEY (order_num)) ENGINE=InnoDB;######################## Create products table#######################CREATE TABLE products( prod_id char(10) NOT NULL, vend_id int NOT NULL , prod_name char(255) NOT NULL , prod_price decimal(8,2) NOT NULL , prod_desc text NULL , PRIMARY KEY(prod_id)) ENGINE=InnoDB;####################### Create vendors table######################CREATE TABLE vendors( vend_id int NOT NULL AUTO_INCREMENT, vend_name char(50) NOT NULL , vend_address char(50) NULL , vend_city char(50) NULL , vend_state char(5) NULL , vend_zip char(10) NULL , vend_country char(50) NULL , PRIMARY KEY (vend_id)) ENGINE=InnoDB;############################ Create productnotes table###########################CREATE TABLE productnotes( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL , PRIMARY KEY(note_id), FULLTEXT(note_text)) ENGINE=MyISAM;###################### Define foreign keys#####################ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175########################### Populate customers table##########################INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES(10001, 'Coyote Inc.', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'Y Lee', 'ylee@coyote.com');INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)VALUES(10002, 'Mouse House', '333 Fromage Lane', 'Columbus', 'OH', '43333', 'USA', 'Jerry Mouse');INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES(10003, 'Wascals', '1 Sunny Place', 'Muncie', 'IN', '42222', 'USA', 'Jim Jones', 'rabbit@wascally.com');INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES(10004, 'Yosemite Place', '829 Riverside Drive', 'Phoenix', 'AZ', '88888', 'USA', 'Y Sam', 'sam@yosemite.com');INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact)VALUES(10005, 'E Fudd', '4545 53rd Street', 'Chicago', 'IL', '54545', 'USA', 'E Fudd');######################### Populate vendors table########################INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES(1001,'Anvils R Us','123 Main Street','Southfield','MI','48075', 'USA');INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES(1002,'LT Supplies','500 Park Street','Anytown','OH','44333', 'USA');INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES(1003,'ACME','555 High Street','Los Angeles','CA','90046', 'USA');INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES(1004,'Furball Inc.','1000 5th Avenue','New York','NY','11111', 'USA');INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES(1005,'Jet Set','42 Galaxy Road','London', NULL,'N16 6PS', 'England');INSERT INTO vendors(vend_id, vend_name, vend_address, vend_city, vend_state, vend_zip, vend_country)VALUES(1006,'Jouets Et Ours','1 Rue Amusement','Paris', NULL,'45678', 'France');########################## Populate products table#########################INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV01', 1001, '.5 ton anvil', 5.99, '.5 ton anvil, black, complete with handy hook');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV02', 1001, '1 ton anvil', 9.99, '1 ton anvil, black, complete with handy hook and carrying case');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV03', 1001, '2 ton anvil', 14.99, '2 ton anvil, black, complete with handy hook and carrying case');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('OL1', 1002, 'Oil can', 8.99, 'Oil can, red');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FU1', 1002, 'Fuses', 3.42, '1 dozen, extra long');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('SLING', 1003, 'Sling', 4.49, 'Sling, one size fits all');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('TNT1', 1003, 'TNT (1 stick)', 2.50, 'TNT, red, single stick');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('TNT2', 1003, 'TNT (5 sticks)', 10, 'TNT, red, pack of 10 sticks');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FB', 1003, 'Bird seed', 10, 'Large bag (suitable for road runners)');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FC', 1003, 'Carrots', 2.50, 'Carrots (rabbit hunting season only)');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('SAFE', 1003, 'Safe', 50, 'Safe with combination lock');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('DTNTR', 1003, 'Detonator', 13, 'Detonator (plunger powered), fuses not included');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('JP1000', 1005, 'JetPack 1000', 35, 'JetPack 1000, intended for single use');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('JP2000', 1005, 'JetPack 2000', 55, 'JetPack 2000, multi-use');######################## Populate orders table#######################INSERT INTO orders(order_num, order_date, cust_id)VALUES(20005, '2005-09-01', 10001);INSERT INTO orders(order_num, order_date, cust_id)VALUES(20006, '2005-09-12', 10003);INSERT INTO orders(order_num, order_date, cust_id)VALUES(20007, '2005-09-30', 10004);INSERT INTO orders(order_num, order_date, cust_id)VALUES(20008, '2005-10-03', 10005);INSERT INTO orders(order_num, order_date, cust_id)VALUES(20009, '2005-10-08', 10001);############################ Populate orderitems table###########################INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20005, 1, 'ANV01', 10, 5.99);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20005, 2, 'ANV02', 3, 9.99);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20005, 3, 'TNT2', 5, 10);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20005, 4, 'FB', 1, 10);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20006, 1, 'JP2000', 1, 55);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20007, 1, 'TNT2', 100, 10);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20008, 1, 'FC', 50, 2.50);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 1, 'FB', 1, 10);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 2, 'OL1', 1, 8.99);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 3, 'SLING', 1, 4.49);INSERT INTO orderitems(order_num, order_item, prod_id, quantity, item_price)VALUES(20009, 4, 'ANV03', 1, 14.99);############################## Populate productnotes table#############################INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(101, 'TNT2', '2005-08-17','Customer complaint:Sticks not individually wrapped, too easy to mistakenly detonate all at once.Recommend individual wrapping.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(102, 'OL1', '2005-08-18','Can shipped full, refills not available.Need to order new can if refill needed.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(103, 'SAFE', '2005-08-18','Safe is combination locked, combination not provided with safe.This is rarely a problem as safes are typically blown up or dropped by customers.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(104, 'FC', '2005-08-19','Quantity varies, sold by the sack load.All guaranteed to be bright and orange, and suitable for use as rabbit bait.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(105, 'TNT2', '2005-08-20','Included fuses are short and have been known to detonate too quickly for some customers.Longer fuses are available (item FU1) and should be recommended.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(106, 'TNT2', '2005-08-22','Matches not included, recommend purchase of matches or detonator (item DTNTR).');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(107, 'SAFE', '2005-08-23','Please note that no returns will be accepted if safe opened using explosives.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(108, 'ANV01', '2005-08-25','Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(109, 'ANV03', '2005-09-01','Item is extremely heavy. Designed for dropping, not recommended for use with slings, ropes, pulleys, or tightropes.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(110, 'FC', '2005-09-01','Customer complaint: rabbit has been able to detect trap, food apparently less effective now.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(111, 'SLING', '2005-09-02','Shipped unassembled, requires common tools (including oversized hammer).');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(112, 'SAFE', '2005-09-02','Customer complaint:Circular hole in safe floor can apparently be easily cut with handsaw.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(113, 'ANV01', '2005-09-05','Customer complaint:Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.');INSERT INTO productnotes(note_id, prod_id, note_date, note_text)VALUES(114, 'SAFE', '2005-09-07','Call from individual trapped in safe plummeting to the ground, suggests an escape hatch be added.Comment forwarded to vendor.'); 图形化效果： customers表： orderitems表： orders表： productnotes表： vendors表： products表：]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查找（一）]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo布局架构及功能分析]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B6%E4%BB%96%2Fhexo%E5%B8%83%E5%B1%80%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[部分文件或文件夹功能介绍： _config.yml hexo博客整体的配置文件 scaffolds post、page、draft的模板文件 post 即新发布的博客 page 主要是about、tags、categories等页面 draft 即草稿 themes 主题文件夹 source about 关于页面 _post 发布的.md微博存储位置 tags 标签页面 ~/blog/themes/next/source/css/_custom 第三方配置文件，在这里写可以覆盖主题默认配置 ~/blog/themes/next/source/css/_schemes/Pisces _brand.styl 修改title块的配置，即黑色背景部分 index.styl 总的配置文件，导入其他配置文件 _layout.styl 正文部分及侧边栏部分配置文件 _sidebar.styl 侧边栏配置文件，删除background-color部分在_layout.styl中的设置才能生效 themes/next/source/css/_variables base.styl 定义了颜色的名字以及其对应的颜色值 1234567$whitesmoke = #f5f5f5$gainsboro = #eee$gray-lighter = #ddd$grey-light = #ccc$grey = #bbb$grey-dark = #999$grey-dim = #666 Pisces.styl 定义了next主题的Pisces主题的各个部分的颜色配置 1234567891011121314151617// Header// --------------------------------------------------$subtitle-color = $gray-lighter// Sidebar// --------------------------------------------------$sidebar-offset = unit(hexo-config(&apos;sidebar.offset&apos;), px) if hexo-config(&apos;sidebar.offset&apos;) is a &apos;unit&apos;$sidebar-nav-hover-color = $orange$sidebar-highlight = $orange$site-author-image-width = 120px$site-author-image-border-width = 1px$site-author-image-border-color = $gainsboro$site-author-name-margin = 0$site-author-name-color = $black-deep 来源：www.holmeyoung.com]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象深入]]></title>
    <url>%2F2018%2F08%2F20%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[包装类 JDK 1.5提供了自动装箱与自动拆箱功能。 将字符串类型转换为基本类型： 利用包装类提供的parseXxx(String s)静态方法 利用包装类提供的Xxx(String s)构造器 将基本类型转换为字符串类型： 利用String类提供的多个重载的valueOf()方法 虽然包装类型为引用数据类型，但包装类的实例可以与数值类型进行比较，这种比较是直接取出包装类的实例所包装的数值来进行比较的。 将一个int类型的值赋给一个Integer类型的实例： 当整数在-128到127之间时，int类型的值会放入一个数组中缓存起来，故同一个整数总是引用同一个数组元素，它们全部相等。 当整数不在这个范围内时，自动装箱后同一个整数对应的实例不相等。 12345678910111213141516171819202122public class IntegerCacheTest&#123; public static void main(String[] args)&#123; Integer in0 = 6; Integer in8 = 6; System.out.println(in0 == in8);//输出true Integer in1 = new Integer(6); Integer in2 = Integer.valueOf(6); Integer in3 = Integer.valueOf(6); System.out.println(in0 == in1);//输出false System.out.println(in0 == in2);//输出true System.out.println(in2 == in3);//输出true System.out.println(in1 == in3);//输出false Integer in4 = Integer.valueOf(200); Integer in5 = Integer.valueOf(200); Integer in6 = 200; Integer in7 = 200; System.out.println(in4 == in5);//输出false System.out.println(in6 == in7);//输出false System.out.println(in4 == in6);//输出false &#125;&#125; 处理对象toString()方法当方法输出一个对象时，实际上输出的是该对象的toString()方法的返回值。 Object类提供的toString()方法总是返回”类名+@+hashCode”值 123Person p = new Person();System.out.println(p);System.out.println(p.toString()); 大部分时候，重写toString()方法总是返回该对象的所有令人感兴趣的信息所组成的字符串。 ==： 对基本类型变量，只要两个变量的值相等即返回true。(不要求数据类型严格相同) 对引用类型变量，只有两个相同或具有父子关系的对象才可判断，只有指向同一对象时才返回true 12345678int r = 4;short t = 4;float y = 4.0f;double q = 4.0;System.out.println(r == t);//输出trueSystem.out.println(r == q);//输出trueSystem.out.println(r == y);//输出trueSystem.out.println('A' == 65);//输出true 常量池专门用来管理在编译时被确定并保存在已编译的.class文件中的一些数据，它包括了关于类、方法、接口中的常量，还包括字符串常量。 String str = “hello”;与String str = new String(“hello”);的区别： 前者使用”hello”字符串直接量，保存在常量池中 后者先用常量池保存”hello”直接量，再调用String的构造器来创建一个新的对象，保存在堆内存中。 JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本。 12345678910111213141516171819202122232425String str1 = "hello";String str2 = "hello";System.out.println(str1 == str2);//输出trueSystem.out.println(str1.equals(str2));//输出trueString str3 = new String("hello");String str4 = new String("hello");System.out.println(str3 == str4);//输出falseSystem.out.println(str3.equals(str4));//输出trueString s1 = "疯狂java";String s2 = "疯狂";String s3 = "java";String s4 = "疯狂" + "java";String s5 = s2 + s3;//编译时不能确定下来String s6 = new String("疯狂java");final String s7 = "疯狂";//直接量final String s8 = "java";//直接量String s9 = s7 + s8;//两个直接量的连接运算，可以在编译阶段被确定System.out.println(s1 == s4);//输出trueSystem.out.println(s1 == s5);//输出falseSystem.out.println(s1 == s9);//输出trueSystem.out.println(s1 == s6);//输出falseSystem.out.println(s1.equals(s5));//输出trueSystem.out.println(s1.equals(s6));//输出true equals()方法Object类提供的equals()方法同样要求两个引用变量指向同一个对象，与==没什么区别，故实际应用中常常需要重写。 String类重写了Object类的equals()方法，只要两个字符串所包含的字符序列相同，即返回true。 正确重写equals()方法需要满足条件： 自反性 对称性 传递性 一致性：只要x与y不变，x.equals(y)返回值不变 对任何不是null的x，x.equals(null)一定返回false 单例类始终只能创建一个实例的类。 将构造器用private修饰，提供一个public static修饰的方法作为访问点。 需要一个private static修饰的成员变量来保存曾经创建过的对象。 1234567891011121314151617181920public class SingletonTest&#123; public static void main(String[] args)&#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1 == s2);//输出true &#125;&#125;class Singleton&#123; private static Singleton instance;//用来缓存曾经创建的实例 private Singleton()&#123;&#125; public static Singleton getInstance()&#123;//提供一个静态方法用于返回单例类的实例 if (instance == null)&#123;//可加入自定义控制保证只产生一个对象 instance = new Singleton(); &#125; return instance; &#125;&#125; final修饰符final可用于修饰类、变量、方法，用于表示它修饰的类、变量、方法不可改变。 final成员变量必须由程序员显示指定初始值。 类变量：必须在静态初始化块中指定初始值或声明该变量时指定初始值，两者之一。 实例变量：必须在非静态初始化块、声明该实例变量或构造器中指定初始值，三者之一。 如果打算在构造器或初始化块中对final成员变量进行初始化，则不要在初始化之前就访问成员变量，因为系统不会进行隐式初始化。 final局部变量如果在定义时未指定默认值，则可以在后面的代码中对该final变量赋初始值，但只能一个，不能重复赋值。若定义时已经指定默认值，则不可再次赋值。 final修饰的形参不能被赋值。 final修饰引用变量时，只能保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。 只要满足以下条件，final变量不再是一个变量，而是相当于一个直接量： 使用final修饰符修饰 在定义该final变量时指定了初始值 该初始值可以在编译时被确定下来 final修饰符的一个重要用途。编译器会把程序中所有用到该变量的地方直接替换成该变量的值。 1234567final int o = 5;final int u = 3-3;System.out.println(u*u);//输出0，没有c语言#define那样的骚操作final String book = "疯狂java讲义：" + 99.0;final String book1 = "疯狂java讲义：" + String.valueOf(99.0);//调用了方法，无法在编译时被确定下来System.out.println(book == "疯狂java讲义：99.0");//输出trueSystem.out.println(book1 == "疯狂java讲义：99.0");//输出false final方法final修饰的方法不可被重写，然而可以在子类中定义相同方法名、形参列表、返回值类型的方法。 可以被重载。 final类不可以有子类。 不可变类创建该类的实例后，该实例的实例变量不可改变。 8个包装类与String类都是不可变类。 原则： 成员变量用private final修饰 提供带参数的构造器初始化成员变量 仅为成员变量提供getter方法，不提供setter方法 如有必要，重写hashCode()方法与equals()方法(用equals()判断为相等的对象的hashCode()也相等) 当创建不可变类时，如果它包含的成员变量的类型是可变的，那么其对象的成员变量的值依然可变，这个不可变类创建失败。(例如包含一个引用类型的成员变量，而这个引用类为可变类) 解决方法： 123456789101112131415161718192021222324252627282930313233343536373839class Name&#123;//一个可变类 private String firstName; private String lastName; public Name()&#123;&#125; public Name(String firstname, String lastname)&#123; this.firstName = firstname; this.lastName = lastname; &#125; public void setFirstName(String firstname)&#123; this.firstName = firstname; &#125; public void setLastName(String lastname)&#123; this.lastName = lastname; &#125; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125;&#125;public class Person&#123;//设计出的不可变类 private final Name name; public Person(Name name)&#123; this.name = new Name(name.getFirstName(), name.getLastName()); &#125; public Name getName()&#123; return new Name(name.getFirstName(), name.getLastName());//返回一个匿名对象 &#125; public static void main(String[] args)&#123; Name name = new Name("Ben","Wen"); Person p = new Person(name); System.out.println(p.getName().getFirstName());//输出Ben name.setFirstName("John"); System.out.println(p.getName().getFirstName());//输出Ben &#125;&#125; 抽象类规则： 使用abstract修饰符来定义。 有抽象方法的类一定是抽象类，抽象类中可以没有抽象方法，也可以有普通方法。 抽象方法没有方法体(即没有{})，结尾有； 抽象类不能被实例化。 抽象类可以包括成员变量、方法、构造器、初始化块、内部类(接口、枚举)，构造器不能用于创建实例，主要被子类调用。 如果子类没有完全实现抽象类中的抽象方法，则子类也必须用abstract修饰。 使用abstract修饰类时，表明这个类必须被继承；使用abstract修饰方法时，表明这个方法必须被重写，因此final与abstract永远不能同时使用！！！ static修饰的方法可以通过类直接调用，但抽象方法被调用时会出现错误，因此static与abstract不能同时修饰一个方法。(不是绝对互斥，可以同时修饰内部类) private与abstract也不能同时修饰方法。 private和final同时修饰方法语法上合法，但意义不大。 抽象类体现的是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在此基础上进行扩展、改造。 接口接口不提供任何实现，它体现的是规范和实现分离的设计哲学。 规则： 使用interface关键字定义接口 接口内不能包含构造器和初始化块，只能包含成员变量(必须为静态常量)、方法(只能为抽象实例方法、类方法或默认方法)、内部类(接口、枚举) 接口的修饰符组合只能为public abstract或只有abstract，后者为包访问权限，abstract为系统自动添加 接口中的成员变量总是public static final修饰，在定义时必须指定初始值，系统自动添加 接口中的普通方法总是public abstract修饰，不能有方法体，系统自动添加 接口中的类方法、默认方法必须有方法体，默认方法为java 8开始支持，必须由public default修饰，public为系统自动添加 接口中的内部类、内部接口、内部枚举总是public static修饰，系统自动添加 接口支持多继承，但只能继承接口，不能继承类。 接口可以用于声明引用类型变量，这个引用类型变量必须引用到实现了该接口的对象。 一个类可以实现多个接口，实现用implements关键字表示。 一个类实现了一个或多个接口后，这个类必须完全实现这些接口里所定义的全部抽象方法，否则将会保留剩下的抽象方法，该类必须声明为抽象类。 实现类中实现的接口中的方法必须为public，因为访问权限只能更大或相等而接口中的抽象实例方法全为public。 所有接口类型的引用变量都可以直接赋给Object类型的引用变量。 默认方法不能重写Object中的方法，但可以重载Object中的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384interface Product&#123; int getProduceTime();&#125;interface Output&#123; int MAX_CACHE_LINE = 50; void out(); void getData(String msg); default void print(String... msgs)&#123; for (String msg : msgs)&#123; System.out.println(msg); &#125; &#125; default void test()&#123; System.out.println("默认的test()方法"); &#125; static String staticTest()&#123; return "接口里的类方法"; &#125;&#125;public class Printer implements Output , Product&#123; private String[] printData = new String[MAX_CACHE_LINE]; private int dataNum = 0; public void out()&#123; while (dataNum &gt; 0)&#123; System.out.println("打印机打印：" + printData[0]); System.arraycopy(printData,1,printData,0,--dataNum);//把作业队列整体前移1位，并将剩下的作业数减1 &#125; &#125; public void getData(String msg)&#123; if(dataNum &gt;= MAX_CACHE_LINE)&#123; System.out.println("输出队列已满，添加失败"); &#125; else&#123; printData[dataNum++] = msg; &#125; &#125; public int getProduceTime()&#123; return 45; &#125; public static void main(String[] args)&#123; Output o = new Printer(); o.getData("1111111"); o.getData("2222222"); o.getData("3333333"); o.out(); System.out.println("----------"); o.getData("4444444"); o.out(); o.print("abc","def","xyz"); o.test(); Output.staticTest(); // System.out.println(o.getProduceTime()); Printer r = new Printer(); System.out.println(r.getProduceTime()); r.getData("7777777"); r.out(); Product p = new Printer(); System.out.println(p.getProduceTime()); // p.getData("5555555");某种接口类型的变量只能调用该种接口中的方法的实现 Object obj = p; // System.out.println(obj.getProduceTime()); &#125;&#125;/*输出：打印机打印：1111111打印机打印：2222222打印机打印：3333333----------打印机打印：4444444abcdefxyz默认的test()方法45打印机打印：777777745*/ 简单工厂模式、命令模式，见疯狂java讲义第三版P196 内部类静态内部类与非静态内部类内部类成员可以直接访问外部类的私有数据，但外部类不能访问内部类的实现细节。 内部类比外部类多三个修饰符：private、protected、static。 非静态内部类不能拥有静态成员(如静态方法、静态成员变量、静态初始化块)。 内部类的class文件总是OuterClass$InnerClass.class格式。 静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。(静态内部类只持有对外部类的引用，没有持有对外部类对象的引用。) 若外部类成员变量、内部类成员变量与内部类中的局部变量同名，则可用外部类类名.this、this来区分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DiscernVariable&#123; private String prop = "外部类的实例变量"; public class Inclass&#123; String prop = "内部类的实例变量"; public void info()&#123; String prop = "局部变量"; System.out.println("外部类的实例变量值：" + DiscernVariable.this.prop); System.out.println("内部类的实例变量值：" + this.prop); System.out.println("局部变量的值：" + prop); &#125; &#125; public void test()&#123; Inclass in = new Inclass(); in.info(); &#125; public static void main(String[] args)&#123; new DiscernVariable().test();//只创建了外部类对象，未创建内部类对象 new DiscernVariable().new Inclass().info(); new CreateInnerInstance().test(); // new Inclass(); &#125;&#125;class CreateInnerInstance&#123; public void test()&#123; DiscernVariable.Inclass in = new DiscernVariable().new Inclass();//在外部类之外使用非静态内部类方法 /*等价于： DiscernVariable.Inclass in; DiscernVariable temp = new DiscernVariable(); in = temp.new Inclass(); */ in.info(); &#125;&#125;/*输出：外部类的实例变量值：外部类的实例变量内部类的实例变量值：内部类的实例变量局部变量的值：局部变量外部类的实例变量值：外部类的实例变量内部类的实例变量值：内部类的实例变量局部变量的值：局部变量外部类的实例变量值：外部类的实例变量内部类的实例变量值：内部类的实例变量局部变量的值：局部变量*/ 使用内部类： 在外部类内部使用内部类时与使用普通类区别不大。 在外部类之外使用非静态内部类时语法为：OuterClass.InnerClass a = new OuterClass().new InnerClass(); 在外包了之外使用静态内部类时语法为：OuterClass.InnerClass a = new OuterClass.InnerClass(); 如果有一个非静态内部类子类的对象存在，则一定存在与之对应的外部类对象。 创建内部类对象时，静态内部类只需使用外部类即可调用构造器，而非静态内部类必须使用外部类对象来调用构造器。 局部内部类方法里定义的内部类称为局部内部类。局部内部类与匿名内部类都不是类成员。 所有局部成员都不能使用static及访问控制修饰符修饰。 局部内部类的class文件名中增加了一个数字，即OuterClass$NInnerClass.class 匿名内部类匿名内部类适合创建那种只需要一次使用的类。 规则： 匿名内部类必须且只能继承一个父类或实现一个接口 匿名内部类不能是抽象类(创建匿名内部类时立即创建其对象) 匿名内部类不能定义构造器(无类名)，但可以定义初始化块 匿名内部类必须实现它的抽象父类或接口中包含的全部方法 当通过实现接口来创建匿名内部类时，不能显示创建构造器，new 接口名后的括号里不能传入参数。 当通过继承父类来创建匿名内部类时，匿名内部类将拥有与父类相似的构造器，即拥有相同的形参列表。 “effectively final”：被匿名内部类访问的局部变量，可以用final修饰，也可以不用final修饰，但必须按照有final修饰的方法来用—-即一次赋值后，不可再次赋值。 12345678910111213141516interface A&#123; void test();&#125;public class ATest&#123; public static void main(String[] args)&#123; int age = 8; A a = new A()&#123; public void test()&#123; System.out.println(age); &#125; &#125;; a.test(); // age = 2;错误: 从内部类引用的本地变量必须是最终变量或实际上的最终变量 &#125;&#125; 修饰符的适用范围 Lambda表达式Lambda表达式与函数式接口Lambda表达式的主要作用就是代替匿名内部类的繁琐语法。 它由三部分组成： 形参列表。当形参列表中只有一个参数时，圆括号可以省略。 箭头 -&gt;。 代码块。如果代码块只包含一条语句，则可以省略花括号。如果代码块只包含一条return语句，则可以省略return，Lambda表达式自动返回这条语句的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface Eatable&#123; void taste();&#125;interface Flyable&#123; String f = "飞碟"; void fly(String weather);&#125;interface Addable&#123; int add(int a,int b);&#125;public class LambdaQs&#123; public void eat(Eatable e)&#123; e.taste(); &#125; public void drive(Flyable f)&#123; System.out.println("我正在驾驶：" + Flyable.f); f.fly("[碧空如洗的晴日]"); &#125; public void test(Addable add)&#123; System.out.println("5与3的和为：" + add.add(5,3)); &#125; public static void main(String[] args)&#123; LambdaQs lq = new LambdaQs(); lq.eat(() -&gt; System.out.println("苹果味道不错!")); lq.drive(weather -&gt; &#123; System.out.println("今天的天气是：" + weather); System.out.println("直升机飞行平稳"); &#125;); lq.test((a, b) -&gt; a + b); &#125;&#125;/*输出：苹果味道不错!我正在驾驶：飞碟今天的天气是：[碧空如洗的晴日]直升机飞行平稳5与3的和为：8*/ Lambda表达式的目标类型必须是明确的“函数式接口”，即只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法（因为Lambda表达式只能实现一个方法）。 java 8提供@FunctionalInterface注释函数式接口。 1234567891011121314151617Runnable r = () -&gt; &#123; for (int i = 0;i &lt; 100;i++)&#123; System.out.println(); &#125;&#125;//合法Object obj = () -&gt; &#123; for (int i = 0;i &lt; 100;i++)&#123; System.out.println(); &#125;&#125;//非法，Object不是明确的函数式接口Object obj = (Runnable)() -&gt; &#123; for (int i = 0;i &lt; 100;i++)&#123; System.out.println(); &#125;&#125;//合法，可以强制类型转换 同样的Lambda表达式的目标类型完全是可以变化的，唯一的要求是其实现的匿名方法与目标类型中唯一的抽象方法具有相同得形参列表。 匿名内部类与Lambda表达式的区别： 匿名内部类可以为任意接口、抽象类甚至普通类创建实例，而Lambda表达式只能为函数式接口创建实例。 匿名内部类实现的抽象方法的方法体中允许调用接口中定义的默认方法，Lambda表达式的代码块不允许调用接口中定义的默认方法。 方法引用与构造器引用 12345678910111213141516171819202122232425262728293031323334353637383940@FunctionalInterfaceinterface Converter&#123; Integer convert(String name);&#125;Converter converter1 = from -&gt; Integer.valueOf(from);Integer val1 = converter1.convert("99");System.out.println(val);第一条语句可转换为：Converter converter1 = Integer :: valueOf;Converter converter2 = from -&gt; "fikt.org".indexOf(from);Integer value = converter2.convert("it");System.out.println(value);第一条语句可转换为：Converter converter2 = "fikt.org" :: indexOf;@FunctionalInterfaceinterface MyTest&#123; String test(String a, int b, int c);&#125;MyTest mt = (a,b,c) -&gt; a.substring(b,c);String str = mt.test("Java I Love you",2,9);System.out.println(str);//输出va I Lo第一条语句可转换为：MyTest mt = String :: substring;@FunctionalInterfaceinterface YourTest&#123; JFrame win(String title);&#125;YourTest yt = (String a) -&gt; new JFrame(a);JFrame jf = yt.win("我的窗口");System.out.println(jf);第一条语句可转换为：YourTest yt = JFrame :: new; 枚举类规则： 枚举类默认继承java.lang.Enum类，而不是Object类，因此枚举类不能显示继承其他父类。 使用enum定义、非抽象的枚举类默认使用final修饰，因此枚举类不能派生子类。 枚举类的构造器只能使用private访问控制符。 枚举类的所有实例必须在枚举类的第一行显示列出，否则这个枚举类永远不能产生实例。 枚举类的实例由系统自动添加public static final修饰，无须显示添加。 枚举类默认提供一个value()方法，可以很方便地遍历所有的枚举值。 switch控制表达式使用枚举类型时，后面的case表达式中可以直接使用枚举类的名字，无须添加枚举类作为限定。 java.lang.Enum提供的部分方法： int compareTo(E o)：与指定枚举对象比较顺序，该枚举对象位于指定枚举对象之后返回正整数。 int ordinal()：返回枚举值在枚举类中的索引值。第一个枚举值的索引值为0。 String toString()：返回枚举常量的名称。 public static &lt;T extends Enum&gt; T valueOf(ClassenumType,String name)：返回指定枚举类中指定名称的枚举值。 枚举类通常应设计为不可变类： 123456789101112public enum Gender&#123; MALE("男"),FEMALE("女"); //等同于public static final Genter MALE = new Gender("男"); //等同于public static final Genter FEMALE = new Gender("女"); private final String name; private Gender(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125;&#125; 枚举类实现接口里的方法时，若需要每个枚举类呈现不同的行为方式，可以使用匿名内部类： 12345678910111213public enum Genter implements GenderDesc&#123; MALE("男")&#123; public void info()&#123; //方法实现 &#125; &#125;, FEMALE("女")&#123; public void info()&#123; //方法实现 &#125; &#125;; //其他部分&#125; 枚举类里定义抽象方法时不能使用abstract关键字将枚举类定义为抽象类(因为系统会自动添加)，且定义每个枚举值时必须为抽象方法提供实现。 对象与垃圾回收 垃圾回收特点： 垃圾回收只负责回收堆内存中的对象，不会回收任何物理资源。(数据库连接、网络IO等) 程序无法精确控制垃圾回收的进行，垃圾回收只会在合适的时候进行。 在；垃圾回收机制回收任何对象之前，总会先调用它的finalize()方法，该方法可能使对象重新复活从而导致垃圾回收机制取消回收。 对象的三种状态： 可达状态：有一个以上的引用变量引用它。 可恢复状态：不再有任何引用变量引用它，系统准备调用其finalize()方法进行资源清理。 不可达状态：系统已经调用finalize()方法仍没有使该对象变成可达状态。系统准备真正回收该对象所占有的资源。 强制垃圾回收：通知系统进行回收，但系统听不听话依然不确定。 两种方法： 调用System类的gc()静态方法：System.gc() 调用Runtime类的gc()实例方法：Runtime.getRuntime().gc() finalize()方法的特点： 永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。 不要把finalize()当成一定会执行的方法。 当JVM执行finalize()方法出现异常时，垃圾回收机制不会报告异常，程序继续进行。 可通过System.runFinalization()方法强制垃圾回收机制调用可恢复对象的finalize()方法。 对象的引用方式： 强引用：一般方式。 软引用：用SoftReference类实现，当一个对象只有软引用时且系统内存足够时，它不会被回收；当系统内存不足时，系统可能会回收它。 弱引用：用WeakReference类实现，当一个对象只有弱引用时，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。 虚引用：用PhantomReference类实现，完全类似于没有引用，对象感受不到虚引用的存在。虚引用必须和引用队列ReferenceQueue联合使用，主要用于跟踪对象被垃圾回收的状态。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础]]></title>
    <url>%2F2018%2F08%2F16%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[面向对象三大特征：封装、继承、多态。 类与对象基本知识类的修饰符：public、final、abstract或完全省略 类的成员：构造器、成员变量、方法、初始化块、内部类（接口、枚举类） 类的作用： 定义变量 创建对象 调用类的类方法或访问类的类变量 static修饰的成员不能访问没有static修饰的成员。 static修饰的成员表明它属于这个类本身，而不属于该类的单个实例，因此通常把static修饰的成员变量和方法称为类变量、类方法。 类是一种引用数据类型，引用变量存放在栈内存中，真正的对象存放在堆内存中。 当程序访问引用变量的成员变量或方法时，实际上访问的是该变量所引用的对象的成员变量或方法。 如果一个java源文件里定义了一个public修饰的类（接口、枚举类），则这个源文件的文件名必须与public修饰的类（接口、枚举类）的名称相同。 对象的this引用this出现的两种情形： 构造器中引用该构造器正在初始化的对象 在方法中引用调用该方法的对象 当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，即只能是当前类。只有当这个方法被调用时，它所代表的对象才确定下来，谁在调用这个方法，this就代表谁。 123public void run()&#123; this.jump();&#125; java允许对象的一个成员直接调用另一个成员，可以省略this前缀。 123public void run()&#123; jump();&#125; static修饰的方法中不能使用this引用。 如果调用static修饰的成员时省略了前面的主调，则默认使用该类作为主调；如果调用没有static修饰的成员时省略了前面的主调，则默认使用this作为主调。 如果方法(构造器)中有个局部变量与成员变量同名，但程序又需要在该方法(构造器)里访问这个被覆盖的成员变量，则必须使用this前缀。 如果在某个方法中把this当作返回值，则可以多次连续调用同一个方法，从而使代码更简洁，但可能造成实际意义的模糊。 123456789101112public class ReturnThis&#123; public int age; public ReturnThis grow()&#123; age++; return this; &#125; public static void main(String[] args)&#123; ReturnThis a = new ReturnThis(); a.grow().grow().grow(); System.out.println(a.age);//输出3 &#125;&#125; 成员变量与局部变量 成员变量的修饰符：public、protected、private、static、final 其中public、protected、private最多出现一个。 类变量从该类的准备阶段开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存范围相同，而实例变量则从实例被创建起开始存在，直到系统完全销毁这个实现，作用域与对应的实例的生存范围相同。 局部变量除了形参外，都必须显式初始化。 局部变量保存在其所在方法的栈内存中，成员变量保存在其所在对象的堆内存中。 方法方法的修饰符：public、protected、private、static、final、abstract 其中public、protected、private最多出现一个，final、abstract最多出现一个。 java中方法的参数传递方式只有一个：值传递。 形参个数可变的方法在最后一个形参的类型后加三个点，表明该形参可以接受多个参数值，多个参数值被当成数组传入。 12345678910111213141516171819202122232425public class OverloadVarargs&#123; public static void main(String[] args)&#123; OverloadVarargs olv = new OverloadVarargs(); olv.test(); olv.test("aa","bb"); olv.test("aa"); olv.test(new String[]&#123;"aa"&#125;); //若想调用形参可变的方法，又只想传入一个参数，可传入字符串数组 &#125; public void test(String msg)&#123; System.out.println(111111111); &#125; public void test(String... books)&#123; System.out.println(222222222); &#125;&#125;/*输出:222222222222222222111111111222222222*/ 这个长度可变的参数既可传入多个参数，也可传入一个数组。 数组形式的形参可以处于形参列表的任何位置，但个数可变的形参只能处于形参列表的最后。一个方法中最多只能有一个长度可变的形参。 方法重载两同一不同：同一个类中方法名相同，但形参列表不同。 方法的其他部分，如返回值类型、修饰符等，与方法重载无任何关系。 构造器构造器的修饰符：public、protected、private三者之一。 构造器既不能定义返回类型，也不能使用void声明没有返回值。（构造器的返回值总是当前类，是隐式的，无须也无法指定）。 构造器是一个类创建对象的根本途径，如果一个类没有构造器，则这个类通常无法创建对象。 如果程序员没有为一个类编写构造器，则系统会为该类提供一个默认的构造器；一旦程序员为一个类提供了构造器，系统将不再为该类提供构造器。 java通过new来调用构造器，从而返回该类的实例。 构造器名必须与类名相同。 初始化块相同类型的初始化块之间有顺序，前面定义的初始化块先执行，后面定义的初始化块后执行。 初始化块的修饰符只能是static。 普通初始化块、声明实例变量指定的默认值都可认为是对象的初始化代码，它们的执行顺序与源程序中的排列顺序相同。 静态初始化块与声明类变量时所指定的初始值都是该类的初始化代码，它们的执行顺序与源程序中的排列顺序相同。 1234567891011121314151617181920212223public class InstanceInitTest&#123; static int c = 5; static &#123; c = 8; d = 7; &#125; static int d = 0; int b = 3; &#123; a = 6; b = 4; &#125; int a = 9; public static void main(String[] args)&#123; System.out.println(new InstanceInitTest().a);//输出9 System.out.println(new InstanceInitTest().b);//输出4 System.out.println(InstanceInitTest.c);//输出8 System.out.println(InstanceInitTest.d);//输出0 &#125;&#125; 普通初始化块负责对对象执行初始化，静态初始化块负责对类进行初始化。 静态初始化块总是比普通初始化块优先执行。（因为它们是在类初始化阶段加载的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Root&#123; static&#123; System.out.println("Root的静态初始化块"); &#125; &#123; System.out.println("Root的普通初始化块"); &#125; public Root()&#123; System.out.println("Root的无参数构造器"); &#125;&#125;class Mid extends Root&#123; static&#123; System.out.println("Mid的静态初始化块"); &#125; &#123; System.out.println("Mid的普通初始化块"); &#125; public Mid()&#123; System.out.println("Mid的无参数构造器"); &#125; public Mid(String msg)&#123; System.out.println("Mid的带参数构造器，其初始值为：" + msg); &#125;&#125;class Leaf extends Mid&#123; static&#123; System.out.println("Leaf的静态初始化块"); &#125; &#123; System.out.println("Leaf的普通初始化块"); &#125; public Leaf()&#123; super("疯狂java讲义"); //先执行super指定的父类构造器，再执行普通初始化块，最后执行子类的构造器 System.out.println("执行Leaf的构造器"); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; new Leaf(); System.out.println("-------------"); new Leaf(); &#125;&#125;/*输出：Root的静态初始化块Mid的静态初始化块Leaf的静态初始化块Root的普通初始化块Root的无参数构造器Mid的普通初始化块Mid的带参数构造器，其初始值为：疯狂java讲义Leaf的普通初始化块执行Leaf的构造器-------------Root的普通初始化块Root的无参数构造器Mid的普通初始化块Mid的带参数构造器，其初始值为：疯狂java讲义Leaf的普通初始化块执行Leaf的构造器*/ 封装将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作与访问。 访问级别： 通常使用protected来修饰一个方法表示希望其子类来重写该方法。 通常要将实例变量设为private，再提供对应的getter、setter方法来访问。 包包名全部是小写字母。 位于包中的类，在文件系统中也必须有与包名层次相同的目录结构。 package语句必须作为源文件的第一条非注释语句。 父包与子包在用法上不存在任何关系，如果父包中的类需要使用子包中的类，则必须使用子包的全名，而不能省略父包部分。 import可以向某个java文件中导入指定包层次下的某个类或全部类（使用*），从而省略写包名。 import static可以导入指定类的某个静态成员变量、方法或全部（使用*），从而省略写类名。 *只能代表类，不能代表包，若需导入子包则需另外导入。 继承java没有多继承，不过可以通过实现多接口来近似代替。 java子类不能获得父类的构造器。 java.lang.Object是所有类的父类。 方法重写：子类包含与父类同名的方法。 两同两小一大： 方法名、形参列表相同 子类方法的返回值类型与父类方法的返回值类型相等或更小 子类方法声明抛出的异常类与父类方法声明抛出的异常类相等或更小 子类方法的访问权限与父类方法的访问权限相等或更大 如果需要在子类方法中调用父类中被覆盖的方法，则可以使用super(实例方法)或父类类名(类方法)作为调用者。 如果父类方法具有private访问权限，则子类无法访问与重写该方法，但可以重新定义一个相同或相似的新方法。 如果子类定义了一个与父类方法有相同的方法名，但参数列表不同的方法，就会形成父类方法与子类方法的重载。 系统在创建子类对象时，依然会为父类中定义的、被隐藏的变量分配内存空间。 super不能出现在static修饰的方法中。 调用父类的构造器super调用的是其父类的构造器，而this调用的是同一个类中重载的构造器，因此，使用super调用父类构造器也必须出现在子类构造器执行体的第一行，所以super与this不会同时出现。 子类继承父类，会继承到父类中的数据，所以要看父类是如何对自己的数据进行初始化的，所以子类在进行对象初始化之前必须先调用父类的构造器。 故：创建任何java对象，最先执行的总是java.lang.Object类的构造器。 如果父类中没有空参数的构造器，则子类的构造器内必须通过super语句指定要访问父类中的哪一个构造器。 使用private修饰这个类的构造器，则子类无法调用该类的构造器，也就无法继承该类。 123456789101112131415161718192021222324252627282930313233class Creature&#123; public Creature()&#123; System.out.println("Creature无参数构造器"); &#125;&#125;class Animal extends Creature&#123; public Animal(String name)&#123; System.out.println("Animal带一个参数的构造器，该动物的name为" + name); &#125; public Animal(String name, int age)&#123; this(name); System.out.println("Animal带两个参数的构造器，该动物的name为" + name + "，其age为" + age); &#125;&#125;public class Wolf extends Animal&#123; public Wolf()&#123; super("灰太狼",3); System.out.println("Wolf的无参数构造器"); &#125; public static void main(String[] args)&#123; new Wolf(); &#125;&#125;/*输出：Creature无参数构造器Animal带一个参数的构造器，该动物的name为灰太狼Animal带两个参数的构造器，该动物的name为灰太狼，其age为3Wolf的无参数构造器*/ 如果父类构造器调用了被其子类重写的方法，则变成调用被子类重写后的方法。 12345678910111213141516171819202122class Base&#123; public Base()&#123; test(); &#125; public void test()&#123; System.out.println("将被子类重写的方法"); &#125;&#125;public class Sub extends Base&#123; private String name; public void test()&#123; System.out.println("子类重写父类的方法，其name字符串长度为" + name.length()); &#125; public static void main(String[] args)&#123; Base s = new Sub(); &#125;&#125;//引发空指针异常 多态java引用变量有两种类型，一个是编译时类型，一个是运行时类型，前者由声明该变量时所用的类型决定，后者由实际赋值给该变量的对象来决定。若编译时类型与运行时类型不同则会出现多态。 多态：相同类型的变量、调用同一方法时呈现出不同的行为特征。 对象的实例变量不具有多态性。 只能调用父类中有的方法和成员变量，若父类中的方法在子类中被重写，则调用重写后的方法，若子类中有同名变量，忽略！！！ 12345678910111213141516171819202122232425262728293031323334353637class BaseClass&#123; public int book = 9; public void base()&#123; System.out.println("父类的普通方法"); &#125; public void test()&#123; System.out.println("父类被覆盖当的方法"); &#125;&#125;public class SubClass extends BaseClass&#123; public String book = "疯狂java讲义"; public int b = 4; public void test()&#123; System.out.println("子类覆盖父类的方法"); &#125; public void sub()&#123; System.out.println("子类的普通方法"); &#125; public static void main(String[] args)&#123; BaseClass a = new SubClass(); System.out.println(a.book);//输出9 // System.out.println(a.b);错误: 找不到符号 a.base();//输出父类的普通方法 a.test();//输出子类覆盖父类的方法 // a.sub();错误: 找不到符号 BaseClass c = new BaseClass(); System.out.println(a instanceof SubClass);//输出true System.out.println(a instanceof BaseClass);//输出true System.out.println(a instanceof Object);//输出true System.out.println(c instanceof SubClass);//输出false System.out.println(c instanceof BaseClass);//输出true System.out.println(c instanceof Object);//输出true &#125;&#125; 通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译类型所定义的成员变量，而不是它运行类型所定义的成员变量。 引用变量的强制类型转换数值类型和布尔类型之间不能进行类型转换。 引用类型之间的转换必须在具有继承关系的两个类型之间进行。 如果试图把一个父类实例转换为子类类型，则这个对象必须是实际上的子类实例才行，否则会引发ClassCastException异常。 可以使用instance运算符判断是否可以成功转换，保证程序更健壮。 instance：前一个操作数为一个引用类型变量，后一个操作数为一个类（接口），判断前者的对象是后者的实例吗/前者的对象实现了后者的接口吗？ instance运算符前面的操作数的编译时类型要么与后面的子类相同，要么与后面的类具有父子关系，否则会编译错误。 后面的类可以是前面的对象的类的子类，不过会返回false。 例子见上。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[流程控制与数组]]></title>
    <url>%2F2018%2F08%2F12%2Fjava%E5%9F%BA%E7%A1%80%2F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[带标签的break和continue 1234567891011121314151617181920212223242526for (int t = 0;t &lt; 3;t++)&#123; for (int u = 0;u &lt; 2;u++) &#123; System.out.println(t + "!!!!!!" + u); break; &#125;&#125;/*输出：0!!!!!!01!!!!!!02!!!!!!0*/outer1:for (int t = 0;t &lt; 3;t++)&#123; for (int u = 0;u &lt; 2;u++) &#123; System.out.println(t + "!!!!!!" + u); break outer1; &#125;&#125;/*输出：0!!!!!!0*/ 123456789101112131415161718192021222324252627282930313233for (int t = 0;t &lt; 3;t++)&#123; for (int u = 0;u &lt; 3;u++) &#123; if (u == 1) continue; System.out.println(t + "!!!!!!" + u); &#125;&#125;/*输出：0!!!!!!00!!!!!!21!!!!!!01!!!!!!22!!!!!!02!!!!!!2*/outer2:for (int t = 0;t &lt; 3;t++)&#123; for (int u = 0;u &lt; 3;u++) &#123; if (u == 1) continue outer2; System.out.println(t + "!!!!!!" + u); &#125;&#125;/*输出：0!!!!!!01!!!!!!02!!!!!!0*/ 基础循环判断语句的注意事项使用if…else语句时，应当把包含范围小的条件放在前面处理。 switch分支语句switch后的控制表达式的数据类型只能是byte、short、char、int四种整数类型、枚举类型（可以是任何枚举类型，而且case表达式中的值直接使用枚举值的名字，无须添加枚举类作为限定）、java.lang.String类型，不能是boolean类型。 不能是StringBuffer、StringBuilder两种字符串类型。 可以省略case后面的花括号。 for循环for循环的循环迭代语句没有与循环体放在一起，因此即使通过continue结束本次循环，循环迭代语句一样会执行。 for循环可以有初始化语句，初始化变量个数不限，但声明语句只能有一个，若要声明多个变量，这些变量应该有相同的数据类型。 foreach循环无须获得数组和集合的长度，无须根据索引来访问数组元素和集合元素，foreach循环自动遍历数组或集合中的每个元素。 1234int[] a = &#123;1,2,3,4,5&#125;;for (int k : a)&#123; System.out.println(k);&#125; 通常不会对循环变量进行赋值，没有意义且容易引起错误。 不能通过foreach循环改变数组元素的值。 数组数组的定义定义数组的两种语法： int[] a; int a[]; 通常用第一种格式，因为int[]是一种引用类型，符合引用变量的定义语法，第二种格式正在逐渐淘汰。 定义数组时不能指定数组长度。 数组的初始化静态初始化初始化时由程序员显示指定每个数组元素的初始值，由系统决定数组长度。 格式：a = new type[]{x1,x2,…}; type[] 必须与a的类型相同或为a的类型的子类。 x1,x2…的类型必须与type[]的类型相同或为其子类的实例。 简化格式：type[] a = {x1,x2,…}; 只有定义数组的同时执行数组初始化才支持使用简化的静态初始化。 动态初始化初始化时程序员只指定数组的长度，由系统为数组元素分配初始值。 格式：a = new type[length]; 整数类型值为0 浮点数类型值为0.0 字符类型值为’\u0000’ 布尔类型值为false 引用类型值为null 不能同时使用静态初始化和动态初始化，即不能在进行数组初始化时既指定数组长度也为每个数组元素分配初始值。 终上所述，定义并初始化数组有三种方法： 12345int[] objArr = new int[]&#123;12,2,3&#125;;int[] objArr1 = &#123;10,2,3&#125;;int[] objArr2 = new int[3];// int[] objArr3 = new int[3]&#123;12,2,3&#125;;非法// int[] objArr4 = new int[];非法 访问数组元素时，若索引值小于0或大于数组的长度，则抛出java.lang.ArrayIndexOutOfBoundsException: N。 定义并初始化二维数组12345678int[][] ae = new int[4][];//ae这个引用变量指向一个长度为4的数组，每个数组元素都是nullint[][] at = new int[3][4];//at这个引用变量指向一个长度为3的数组，每个数组元素都指向一个长度为4//的int[]类型的数组，每个数组元素的值为0//int[][] ae = new int[][4];非法int[][] aw = new int[][]&#123;&#123;1,2&#125;,&#123;2,3&#125;&#125;;String[][] str9 = &#123;new String[3],new String[]&#123;"hello!"&#125;&#125;;]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[盘点java数值运算中的那些骚操作]]></title>
    <url>%2F2018%2F08%2F12%2Fjava%E5%9F%BA%E7%A1%80%2F%E7%9B%98%E7%82%B9java%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[标识符和关键字 java标识符必须由字母、下划线、数字、美元符($)组成，其中数字不能做开头。 字母为Unicode字符集所支持的字符，包括但不限于中文字符、日本字符等。 特殊字符只能包含美元符，其他字符如@、#等不行。 严格区分大小写。 不能含有空格。 java一共包含50个关键字(至java 8)，均为小写。 goto和const为保留字，至今仍未使用(java 8)，但不代表以后不使用。 三个特殊直接量：true、false、null。 基本数据类型整型直接给出一个整数值默认为int类型。 将一个较小的整数值(byte或short类型范围内)赋值给一个byte或short变量，系统自动将其当做byte或short类型处理。 byte占一个字节，short占两个字节。 将一个超过int类型的整数值赋值给long时，java不会自动将这个整数值当long类型来处理，必须得在后面加上L或l。 12345678910111213//java 7引入功能：在整型或浮点型数值中可以任意使用下划线分隔//输入的是补码int a = 0B1000_0000_0000_0000_0000_0000_0000_0011;System.out.println(a);//输出-2147483645 int b = 0B1000_0000_0000_0000_0000_0000_0000_0011L;System.out.println(b);//非法long c = 0B1000_0000_0000_0000_0000_0000_0000_0011L;System.out.println(c);//输出2147483651long d = 0B1000_0000_0000_0000_0000_0000_0000_0011;System.out.println(d);//输出-2147483645 字符型char类型占两个字节。 三种表示形式： 直接通过单个字符来表示：’A’、’9’、’0’等。 通过转义字符表示特殊字符型值：’\n’、’\t’等。 直接使用Unicode值来表示字符型值：’\uXXXX’，其中XXXX代表一个十六进制整数。 浮点型java浮点型默认为double类型的值，若希望当成float类型处理需要加上f或F。 1234567891011121314151617181920float a = 5.2388858694f;System.out.println(a);//输出5.238886float b = 5.2388858694;System.out.println(b);//非法double c = 5.2388858694;System.out.println(c);//输出5.2388858694double d = 5.2388858694f;System.out.println(d);//输出5.238885679516602(小数点第六位之后为随机输出)float q1 = 5.6;System.out.println(q1);//非法float q2 = 5.6f;System.out.println(q2);//输出5.6float q3 = 5;System.out.println(q3);//输出5.0 正无穷大通过Double类或Float类的POSITIVE_INFINITY来表示，负无穷大通过Double类或Float类的NEGATIVE_INFINITY来表示，非数用Double类或Float类的NaN来表示。 所有正无穷大都相等，所有负无穷大也相等，NaN不与任何数值相等，与其本身也不相等。 只有浮点数除以0才能得到正负无穷大，如果整数值除以0则会抛出异常：java.lang.ArithmeticException: / by zero(除以0异常)。 1234567891011121314151617System.out.println(5.13 / 0);//输出InfinitySystem.out.println(-5.13 / 0);//输出-InfinitySystem.out.println(0.0 / 0.0);//输出NaNSystem.out.println(0 / 0);//非法double q = 0.0;System.out.println(q/q == Float.NaN);//输出falsedouble s = Double.NEGATIVE_INFINITY;float g = Float.NEGATIVE_INFINITY;double m = Float.POSITIVE_INFINITY;//float n = Double.POSITIVE_INFINITY;非法System.out.println(Double.NaN == Float.NaN);//输出falseSystem.out.println(s == g);//输出trueSystem.out.println(s == m);//输出falseSystem.out.println(6.0 / 0 == 100.0 / 0);//输出true 自动类型转换 当把任何基本类型的值和字符串值进行连接运算时，基本类型的值将会自动转换为字符串类型。 当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将会发生自动提升： 所有byte类型、short类型、char类型将被提升到int类型。 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。 1234567891011121314151617String str1 = 2.5f + "";System.out.println(str1);//输出2.5String str2 = true + "";System.out.println(str2);//输出trueSystem.out.println(3 + 4 + "Hello");//输出7HelloSystem.out.println("Hello" + 3 + 4);//输出Hello34System.out.println('a' + 2 + "Hello");//输出99HelloSystem.out.println("Hello" + 'a' + 2);//输出Helloa2short s = 5;//s = s-2;非法s = (short)(s-2);//合法s -= 2;//合法System.out.println(s);//输出1 强制类型转换缩小转换会发生数据丢失： 12345byte a = (byte)0B11101001;System.out.println(a);//输出-23int b = 0B11101001;System.out.println(b);//输出233 运算符求余运算符和自加自减运算符均可以操作浮点型。 12345678System.out.println(5.2 % 2.5);//输出0.20000000000000018System.out.println(5 % 0.0);//输出NaNSystem.out.println(0 % 5);//输出0System.out.println(0 % 0.0);//输出NaNfloat w = 4.3f;w++;System.out.println(w);//输出5.3 位运算符(7个)12345678System.out.println(5 | 9);//输出13System.out.println(5 &amp; 9);//输出1System.out.println(~-5);//输出4System.out.println(5 ^ 9);//输出12System.out.println(5 &lt;&lt; 2);//输出20System.out.println(-5 &lt;&lt; 2);//输出-20System.out.println(-5 &gt;&gt; 2);//输出-2System.out.println(-5 &gt;&gt;&gt; 2);//输出107374182 以上均是对补码进行操作。 右移运算符&gt;&gt;：把第一个操作数的二进制码右移指定位数(第二个操作数指定)后，左边空出来的位用原来的符号位来填充。 无符号右移运算符&gt;&gt;&gt;：把第一个操作数的二进制码右移指定位数(第二个操作数指定)后，左边空出来的位总是用0来填充。 移位运算原则： 对于低于int类型的操作数总是先自动类型转换为int类型后再移位。 对于int类型的整数a&gt;&gt;b，当b&gt;32时，系统先对32求余，得到的结果才是真正移位的位数。 对于long类型的整数a&gt;&gt;b，当b&gt;64时，系统先对64求余，得到的结果才是真正移位的位数。 若移位没有发生有效位的丢失，则左移n位相当于乘以2的n次方，右移n位相当于除以2的n次方。 比较运算符对于==和!=运算符，如果两个操作数都是引用类型，那么只有当两个引用变量类型具有父子关系时才可以比较，而且这两个引用必须指向同一个对象(不同对象)才会返回true。 逻辑运算符123456789101112System.out.println(!false);//输出trueSystem.out.println(5 &gt; 3 &amp;&amp; '6' &lt; 10);//输出falseint x = 10;if (5 &gt; 4 &amp;&amp; ++x &gt; 10) System.out.println(x);//输出11if (5 &gt; 4 &amp; ++x &gt; 10) System.out.println(x);//输出12if (5 &gt; 4 || ++x &gt; 10) System.out.println(x);//输出12if (5 &gt; 4 | ++x &gt; 10) System.out.println(x);//输出13 对于短路逻辑或||而言，如果第一个数返回true，则不再对第二个操作数求值，直接返回true；而不短路或|总是执行前后两个操作数。 对于短路逻辑与&amp;&amp;而言，如果第一个数返回false，则不再对第二个操作数求值，直接返回false；而不短路与&amp;总是执行前后两个操作数。 运算符结合的结合性与优先级除单目运算符、赋值运算符、三目运算符是从右到左结合的，其他运算符都是从左到右结合的。]]></content>
      <categories>
        <category>java</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java控制台五子棋游戏]]></title>
    <url>%2F2018%2F08%2F12%2Fjava%E5%BA%94%E7%94%A8%2Fjava%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[纪念我的第一次实践。 注意： 本项目在IDEA下调试完毕，已解决目前已知所有bug，sublime上似乎跑不了，eclipse没有试过。（更新：只能在IDEA上跑，将其打包成jar后通过Powershell跑棋盘会错位） 棋盘方格为搜狗输入法下的制表符，为了保证棋盘的美观，需设定IDEA控制台行间距为0.7。 本项目电脑玩家落子设定为在用户最后一次落子周围八格内随机落子，若有大佬能提供合适的人工智能算法请联系QQ：549007298，感激不尽。 本项目判断是否获胜设定为依次检查最后一次落子所在的每行每列及每条对角线的同色连续棋子数，若有大佬能提供更优化的算法联系方式同上。 本项目前期曾参考java控制台五子棋游戏。 若有疑问，欢迎咨询，联系方式同上。 源码如下： 棋盘类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package Gobang;/*Created by Ben Wen on 2018/8/9.*/import static Gobang.Gobang.computer;import static Gobang.Gobang.man;import static Gobang.Gobang.order;public class Chessboard &#123;//棋盘类 public static int BOARD_SIZE = 15;//棋盘大小 public static String BLACK = "○"; public static String WHITE = "●"; public String[][] board;//表示棋盘的数组 public int numChess = 0;//棋子总数 public void initBoard ()&#123;//初始化棋盘 board = new String[BOARD_SIZE][BOARD_SIZE]; for (int i = 0;i &lt; BOARD_SIZE;i++) &#123; for (int j = 0;j &lt; BOARD_SIZE;j++) &#123; board[i][j] = "╋"; &#125; &#125; &#125; public void printBoard ()&#123;//打印棋盘（用了些骚操作，为了保证棋盘的美观需设定IDEA控制台行间距为0.7） System.out.println(" 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 X轴"); for (int i = 0;i &lt; BOARD_SIZE;i++) &#123; if (i &lt; 9)&#123; System.out.print("0"+ (i+1)); &#125; else &#123; System.out.print(i+1); &#125; for (int j = 0;j &lt; BOARD_SIZE;j++) &#123; if (j != BOARD_SIZE-1) System.out.print(board[j][i] + "━");//注意此处将棋盘做了一次翻转处理 else System.out.println(board[j][i]); &#125; if (i != BOARD_SIZE-1)&#123; for (int j = 0;j &lt; BOARD_SIZE-1;j++)&#123; System.out.print(" ┃"); &#125; System.out.println(" ┃"); &#125; &#125; System.out.println("Y轴\n"); &#125; public void setBoard(int PosX,int PosY,int chessman)&#123;//落子 if (order == 1)&#123; if (chessman == computer) board[PosX-1][PosY-1] = WHITE; else board[PosX-1][PosY-1] = BLACK; &#125; else &#123; if (chessman == man) board[PosX-1][PosY-1] = WHITE; else board[PosX-1][PosY-1] = BLACK; &#125; numChess++;//总棋子数加1 &#125;&#125; 游戏类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290package Gobang;/*Created by Ben Wen on 2018/8/9.*/import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import static Gobang.Chessboard.BLACK;import static Gobang.Chessboard.BOARD_SIZE;import static Gobang.Chessboard.WHITE;public class Gobang &#123;//游戏类 public static final int computer = 1;//用来表示电脑玩家 public static final int man = 2;//用来表示用户 public static final int WIN_COUNT = 5;//用来表示获胜所需连子数 public static int order;//用来表示执行顺序，1表示用户执黑先走，2表示用户执白后走 private int PosX; private int PosY; private int winner;//用来表示获胜方 private int[] computerPosArr;//用来获取computerDo方法的返回值 private Chessboard chessboard; private int[] a = &#123;0,1,2,3,4&#125;; private Gobang (Chessboard chessboard)&#123; this.chessboard = chessboard; &#125;//构造函数，便于使用Chessboard类的方法 public static void main(String[] args)&#123; new Gobang(new Chessboard()).start(); &#125; private void start ()&#123; boolean isOver = false;//游戏是否结束的标志 chessboard.initBoard();//初始化棋盘 System.out.println("请选择您是黑子先走(1)还是白子后走(2)："); while (true) &#123;//获取order的值，即执行顺序 try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));//获取用户输入 order = Integer.parseInt(reader.readLine()); if (order == 1 || order == 2) &#123; break; &#125; System.out.println("输入错误，请输入数字1或2："); &#125; catch (Exception e) &#123; System.out.println("输入错误，请输入数字1或2："); &#125; &#125; if (order == 1) &#123;//用户执黑先走 chessboard.printBoard();//打印棋盘 System.out.println("请输入您下棋的坐标，应以x(空格)y的格式，其中x、y为不大于15的正整数："); try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String inputStr = null; while ((inputStr = reader.readLine()) != null) &#123; try &#123; isOver = false;//游戏未结束 String[] posStrArr = inputStr.split(" "); PosX = Integer.parseInt(posStrArr[0]);//提取出用户输入中的x坐标 PosY = Integer.parseInt(posStrArr[1]);//提取出用户输入中的y坐标 if (!isValid(PosX, PosY, man)) &#123;//判断用户输入是否合理 continue; &#125; chessboard.setBoard(PosX, PosY, man);//用户落子 if (isWin(PosX, PosY, man)) &#123;//判断用户是否获胜 isOver = true;//游戏可以结束 winner = man;//获胜者为用户 &#125; else &#123;//用户未获胜 computerPosArr = computerDo();//获取电脑玩家输入 chessboard.setBoard(computerPosArr[0], computerPosArr[1], computer);//电脑玩家落子 if (isWin(computerPosArr[0], computerPosArr[1], computer)) &#123;//判断电脑玩家是否获胜 isOver = true;//游戏可以结束 winner = computer;//获胜者为电脑 &#125; &#125; if (isOver) &#123;//游戏是否结束 if (isReplay(winner)) &#123;//是否重新开始 chessboard.initBoard(); &#125; else break; &#125; chessboard.printBoard(); System.out.println("请输入您下棋的坐标，应以x(空格)y的格式，其中x、y为不大于15的正整数："); &#125; catch (NumberFormatException e) &#123;//数字格式异常，当未按正确格式输入但PosX、PosY均有值时抛出 System.out.println("输入错误，请按 数字(空格)数字 格式输入："); &#125; catch (ArrayIndexOutOfBoundsException e) &#123;//数组越界，当只输入了一个值，即PosY无值时抛出 System.out.println("输入错误，请按 数字(空格)数字 格式输入："); &#125; &#125; &#125; catch (IOException e) &#123;//当输入时出现异常时抛出 e.printStackTrace(); &#125; &#125; else &#123;//用户执白后走 while (true) &#123; computerPosArr = computerDo(); chessboard.setBoard(computerPosArr[0], computerPosArr[1], computer); chessboard.printBoard();//先打印电脑玩家落子后的棋盘 if (isWin(computerPosArr[0], computerPosArr[1], computer)) &#123; winner = computer; isOver = true; &#125; else &#123;//如果电脑玩家未获胜，则获取用户输入 System.out.println("请输入您下棋的坐标，应以x(空格)y的格式，其中x、y为不大于15的正整数："); try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String inputStr = null; while ((inputStr = reader.readLine()) != null)&#123; try &#123; String[] posStrArr = inputStr.split(" "); PosX = Integer.parseInt(posStrArr[0]);//提取出用户输入中的x坐标 PosY = Integer.parseInt(posStrArr[1]);//提取出用户输入中的y坐标 if (!isValid(PosX, PosY, man)) &#123; continue; &#125; chessboard.setBoard(PosX, PosY, man); if (isWin(PosX, PosY, man)) &#123; winner = man; isOver = true; &#125; &#125; catch (NumberFormatException e) &#123; System.out.println("输入错误，请按 数字(空格)数字 格式输入："); continue; &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("输入错误，请按 数字(空格)数字 格式输入："); continue; &#125; break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (isOver) &#123; if (isReplay(winner)) &#123; chessboard.initBoard(); isOver = false; &#125; else break; &#125; &#125; &#125; &#125; private int[] computerDo () &#123;//获取电脑玩家落子（思路为在用户最近一次落子周围八个点中随机落子） boolean isRight = false; int randomX = 0; int randomY = 0; while (!isRight) &#123; randomX = (int)Math.round((Math.random() * 3) - 1.5);//在-1,0,1中随机获取一值（round方法表示四舍五入） randomY = (int)Math.round((Math.random() * 3) - 1.5); if (Math.abs(randomX) != 2 &amp;&amp; Math.abs(randomY) != 2) &#123;//排除当randomX和randomY等于正负2的情况 if (PosX == 0 &amp;&amp; PosY == 0) &#123;//若电脑玩家走第一步，则随机获取落子点 PosX = (int)(Math.random() * BOARD_SIZE); PosY = (int)(Math.random() * BOARD_SIZE); &#125; if (isValid(PosX+randomX, PosY+randomY, computer)) &#123;//判断该获取的点是否合理 isRight = true;//合理则退出循环 &#125; &#125; &#125; int[] computerPosArr = &#123;randomX+PosX, randomY+PosY&#125;;//将结果以数组形式返回 return computerPosArr; &#125; private boolean isWin (int PosX, int PosY, int chessman) &#123;//判断是否获胜 String chess;//用来表示此次调用方法需要判断的棋子的颜色 int samecount = 1;//用来统计连子数 boolean right1 = true;//表示某一个方向上同色棋子是否连续 boolean right2 = true;//表示另一个方向上同色棋子是否连续 if (order == 1) chess = ((chessman == man) ? BLACK : WHITE); else chess = ((chessman == computer) ? BLACK : WHITE); if (chessboard.numChess &lt; 9)//当总棋子数小于9时一定不会有一方获胜 return false; for (int i = 1;i &lt; WIN_COUNT &amp;&amp; (right1 || right2);i++)&#123;//判断左右方向是否满足5连子 if (right1 &amp;&amp; PosX+a[i] &gt;= 1 &amp;&amp; PosX+a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX+a[i]-1][PosY-1].equals(chess))&#123; samecount++; &#125; else right1 = false; if (right2 &amp;&amp; PosX-a[i] &gt;= 1 &amp;&amp; PosX-a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX-a[i]-1][PosY-1].equals(chess))&#123; samecount++; &#125; else right2 = false; &#125; if (samecount &gt;= 5) return true; samecount = 1; right1 = true; right2 = true; for (int i = 1;i &lt; WIN_COUNT &amp;&amp; (right1 || right2);i++)&#123;//判断上下方向是否满足5连子 if (right1 &amp;&amp; PosY+a[i] &gt;= 1 &amp;&amp; PosY+a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX-1][PosY+a[i]-1].equals(chess))&#123; samecount++; &#125; else right1 = false; if (right2 &amp;&amp; PosY-a[i] &gt;= 1 &amp;&amp; PosY-a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX-1][PosY-a[i]-1].equals(chess))&#123; samecount++; &#125; else right2 = false; &#125; if (samecount &gt;= 5) return true; samecount = 1; right1 = true; right2 = true; for (int i = 1;i &lt; WIN_COUNT &amp;&amp; (right1 || right2);i++)&#123;//判断左上--右下方向是否满足5连子 if (right1 &amp;&amp; PosX+a[i] &gt;= 1 &amp;&amp; PosX+a[i] &lt;= 15 &amp;&amp; PosY+a[i] &gt;= 1 &amp;&amp; PosY+a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX+a[i]-1][PosY+a[i]-1].equals(chess))&#123; samecount++; &#125; else right1 = false; if (right2 &amp;&amp; PosX-a[i] &gt;= 1 &amp;&amp; PosX-a[i] &lt;= 15 &amp;&amp; PosY-a[i] &gt;= 1 &amp;&amp; PosY-a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX-a[i]-1][PosY-a[i]-1].equals(chess))&#123; samecount++; &#125; else right2 = false; &#125; if (samecount &gt;= 5) return true; samecount = 1; right1 = true; right2 = true; for (int i = 1;i &lt; WIN_COUNT &amp;&amp; (right1 || right2);i++)&#123;//判断左下--右上方向是否满足5连子 if (right1 &amp;&amp; PosX-a[i] &gt;= 1 &amp;&amp; PosX-a[i] &lt;= 15 &amp;&amp; PosY+a[i] &gt;= 1 &amp;&amp; PosY+a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX-a[i]-1][PosY+a[i]-1].equals(chess))&#123; samecount++; &#125; else right1 = false; if (right2 &amp;&amp; PosX+a[i] &gt;= 1 &amp;&amp; PosX+a[i] &lt;= 15 &amp;&amp; PosY-a[i] &gt;= 1 &amp;&amp; PosY-a[i] &lt;= 15 &amp;&amp; chessboard.board[PosX+a[i]-1][PosY-a[i]-1].equals(chess))&#123; samecount++; &#125; else right2 = false; &#125; if (samecount &gt;= 5) return true; return false; &#125; private boolean isValid (int PosX, int PosY, int chessman)&#123;//判断输入是否合理 if (PosX &lt; 1 || PosX &gt; BOARD_SIZE || PosY &lt; 1 || PosY &gt; BOARD_SIZE)&#123; if (chessman == man)//若判断玩家输入时的合理性时才输出这句话 System.out.println("坐标只能为小于等于" + (BOARD_SIZE) + "的正整数，请重新输入："); return false; &#125; if (!chessboard.board[PosX-1][PosY-1].equals("╋"))&#123; if (chessman == man) System.out.println("当前位置已有棋子，请重新输入："); return false; &#125; return true; &#125; private boolean isReplay (int chessman)&#123;//判断是否开始新的一局 int x = chessboard.numChess;//表示总棋子数 int y;//表示用户落子数 if (order == 1)&#123; if (x % 2 == 0) y = x / 2; else y = x / 2 + 1; &#125; else y = x / 2; if (chessman == man)&#123; chessboard.printBoard(); System.out.println("恭喜你赢了！共落子" + x + "粒。其中您落子" + y + "粒。"); &#125; else System.out.println("很遗憾你输了！共落子" + x + "粒。其中您落子" + y + "粒。"); System.out.println("是否再来一局？(y/n)"); try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); if (reader.readLine().equals("y")) &#123; chessboard.numChess = 0; return true; &#125; else return false; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>java应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图的拓扑排序与关键路径]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[拓扑排序 AOV网：在一个表示工程的有向图中，用顶点表示活动，用弧边数活动间的优先关系，这样的有向图表示活动的网，称为AOV网。 AOV网中不能出现回路。 拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1,v2,…,vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必须在顶点vj之前·，这样的序列称为拓扑序列。 拓扑排序：对一个有向图构造拓扑序列的过程。 算法的基本思路：从一个网中选择一个入度为0的顶点输出，然后删除此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点(表明是AOV网)或不存在入度为0的顶点为止。 所用结构：增加入度域的邻接表 12345678910111213141516171819typedef struct EdgeNode&#123; int adjvex; int weight; struct EdgeNode *next;&#125;EdgeNode;typedef struct VertexNode&#123; int in; int data; EdgeNode *firstedge;&#125;VertexNode,AdjList[MAXVEX];typedef struct&#123; AdjList adjlist; int numVertexes,numEdges;&#125;graphAdjList,*GraphAdjList; 算法(需要辅助数据结构–栈): 12345678910111213141516171819202122232425262728Status TopologicalSort(GraphAdjList GL)&#123; EdgeNode *e; int top = -1;//栈指针下标 int count = 0;//统计输出顶点个数 int *stack;//创建栈，用于存储入度为0的顶点 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (int i = 0;i &lt; GL-&gt;numVertexes;i++) if (GL-&gt;adjList[i].in == 0) stack[++top] = i;//将最开始入度为0的顶点入栈 while (top != -1) &#123; int gettop = stack[top--];//将一个入度为0的顶点出栈进行操作 printf("%d -&gt; "GL-&gt;adjList[gettop].data); count++; for (e = GL-&gt;adjList[gettop].firstedge;e;e = e-&gt;next) //遍历刚出栈顶点的所有相邻接顶点，将新的入度为0的顶点入栈 &#123; int k = adjVex; if (!(--GL-&gt;adjList[k].in)) stack[++top] = k; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return ERROR; else return OK;&#125; 时间复杂度为O(n+e)。 该算法执行结果仅仅为所有拓扑排序方案的一种。 关键路径相关概念：AOE网：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。 没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。一般情况下AOE网只有一个源点一个汇点。 AOV网是顶点表示活动的网，它只描述活动之间的制约关系，而AOE网是用边表示活动的网，边上的权值表示活动的持续时间。AOE网要建立在活动没有矛盾的基础之上，再来分析完成整个工程至少需要多少时间，或为缩短完成工程所需时间，应加快哪些活动等问题。 我们把路径上各个活动的持续时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。 只有缩短关键路径上的关键活动时间才能减少整个工期的长度。 算法原理：我们只需找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径，如果不等，则就不是。 几个参数： 事件最早发生的时间etv：即顶点vk的最早发生时间。 事件最晚发生的时间ltv：顶点vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间会延误整个工期。 活动最早开工的时间ete：即弧ak的最早发生时间。 活动最晚开工的时间lte：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间。 通过1和2可以求得3和4，然后再根据ete[k]是否等于lte[k]相等来判断ak是否是关键活动。 算法：1234//全局变量int *etv,*ltv;//事件最早发生时间与最晚发生时间数组int *stack2;//用于存储拓扑序列的栈int top2;//stack2的指针 1234567891011121314151617181920212223242526272829303132333435363738//改进的拓扑排序算法Status TopologicalSort(GraphAdjList GL)&#123; EdgeNode *e; int top = -1;//栈指针下标 int count = 0;//统计输出顶点个数 int *stack;//创建栈，用于存储入度为0的顶点 stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int)); for (int i = 0;i &lt; GL-&gt;numVertexes;i++) if (GL-&gt;adjList[i].in == 0) stack[++top] = i;//将最开始入度为0的顶点入栈 top2 = -1; etv = (int*)malloc(GL-&gt;numVertexes*sizeof(int)); for(int i = 0;i &lt; GL-&gt;numVertexes;i++) etv[i] = 0;//初始化为0 stack2 = (int*)malloc(GL-&gt;numVertexes*sizeof(int)); while (top != -1) &#123; int gettop = stack[top--];//将一个入度为0的顶点出栈进行操作 count++; stack2[++top2] = gettop;//将弹出的顶点序号压入拓扑序列的栈 for (e = GL-&gt;adjList[gettop].firstedge;e;e = e-&gt;next) //遍历刚出栈顶点的所有相邻接顶点，将新的入度为0的顶点入栈 &#123; int k = adjVex; if (!(--GL-&gt;adjList[k].in)) stack[++top] = k; if ((etv[gettop]+e-&gt;weight) &gt; etv[k])//求各顶点事件最早发生的时间值 etv[k] = etv[gettop] + e-&gt;weight; &#125; &#125; if (count &lt; GL-&gt;numVertexes) return ERROR; else return OK;&#125; 求etv[k]时需注意，必须将之前所有事件发生了之后才能发生顶点vk的事件，故当 (etv[gettop]+e-&gt;weight) &gt; etv[k] 时改变etv[k]的值。 123456789101112131415161718192021222324252627282930313233void CriticalPath(GraphAdjList GL)&#123; EdgeNode *e; int k; int ete,lte;//声明活动最早开工时间和最晚开工时间变量 TopologicalSort(GL);//求拓扑序列，计算数组etv与stack2的值 ltv = (int*)malloc(GL-&gt;numVertexes*sizrof(int));//事件最晚发生时间 for (int i = 0;i &lt; GL-&gt;numVertexes;i++) ltv[i] = etv[GL-&gt;numVertexes-1];//初始化ltv while (top2 != -1) &#123; int gettop = stack2[top2--]; for (e = GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next) &#123;//求各顶点事件的最迟发生时间ltv值 k = e-&gt;adjvex; if ((ltv[k] - e-&gt;weight) &lt; ltv[gettop]) ltv[gettop] = ltv[k] - e-&gt;weight;// &#125; &#125; for (int j = 0;j &lt; GL-&gt;numVertexes;j++) &#123; for (e = GL-&gt;adjList[j].firstedge;e;e = e-&gt;next) &#123; k = e-&gt;adjVex; ete = etv[j];//活动的最早开工时间,即该活动前一个事件最早发生的时间 ltv = ltv[k] - e-&gt;weight;//活动的最迟开工时间,即该活动后一个事件最迟发生的时间向前推移该活动所需的时间的结果 if (ele == lte)//如果两者相等，说明活动仅仅只能在这一刻开工，无任何缓冲余地，即该活动在关键路径上 printf("&lt;v%d,v%d&gt; length: %d , ",GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight); &#125; &#125;&#125; 求ltv时，各事件最迟发生的时间为 其后面的事件最迟发生的时间向前提前对应的活动所需时间后最早的时间，即，一旦超过了该时间，一定有至少一个后面的事件发生的时间超过其最迟发生时间，以此类推，整个工期必被加长。 时间复杂度为O(n+e)。 如果是多条关键路径，则只提高一条关键路径上的关键活动的速度并不能缩短整个工程的工期，必须同时提高几条关键路径上的活动的速度才行。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图的最短路径算法]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于网图来说，最短路径是指两顶点间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。 迪杰斯特拉(Dijkstra)算法 思路：按路径长度递增的次序产生最短路径，从某一个顶点开始，寻找与当前整体距离最近的顶点，依次找下去，直到到达终点。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#define MAXVEX 9#define INFINITY 65535typedef int Pathmatirx[MAXVEX];//用于存储最短路径下标数组typedef int ShortPathTable[MAXVEX];//用于存储到当前整体到其余各点最短路径的权值和void ShortestPath_Dijkstra (MGraph G,int v0,Pathmatirx *P,ShortPathTable *D)&#123; int min,k; int final[MAXVEX];//final[w]=1表示求得顶点v0至vw的最短路径 for (int v = 0;v &lt; G.numVertexes;v++) &#123; final[v] = 0;//全部顶点初始化为未知路径状态 (*D)[v] = G.arc[v0][v];//用当前整体v0到各个顶点的边的权值初始化数组D (*P)[v] = 0;//初始化路径数组为0 &#125; (*D)[v0] = 0;//v0到v0的路径为0(这句话似乎可以省略???) final[v0] = 1;//v0到v0不需要求路径 for (int v = 1;v &lt; G.numVertexes;v++) &#123; min = INFINITY; for (int w = 0;w &lt; G.numVertexes;w++) &#123; if (!final[w] &amp;&amp; (*D)[w] &lt; min) &#123; k = w;//更新为最小权值所在边另一个顶点的下标 min = (*D)[w];//更新为离当前整体的最小权值 &#125; &#125; //该循环用于寻找离当前整体最近的顶点 final[k] = 1;//将目前找到的最近的顶点置为1 for (int w = 0;w &lt; G.numVertexes;w++) &#123; if (!final[w] &amp;&amp; (min + G.arc[k][w] &lt; (*D)[w])) &#123; //说明找到了更短的路径，修改两数组 (*D)[w] = min + G.arc[k][w]; (*P)[w] = k; &#125; &#125;//该循环用于取新整体与原整体到其余顶点的边的权值的最小值来更新数组D //或者说通过新顶点搭桥产生的路径变化 &#125;&#125; 理解上注意：该算法并不会刻意寻找到某个顶点的最短路径，因此不能按照一笔画的思路来理解该算法。 final数组最终为:{1,1,1,1,1,1,1,1,1}，它表示所有顶点均完成了最短路径的查找工作。 D数组最终为:{0,1,4,7,5,8,10,12,16}，它表示v0到各个顶点的最短路径数，如v0到v8的最短距离为16。 P数组最终为:{0,0,1,4,2,4,3,6,7}，它表示最短路径所经过的顶点，P[8]=7的意思是v8的前驱顶点是v7，如v0到v8经过的路径为v8←v7←v6←v3←v4←v2←v1←v0。 可以得到v0到任意一个顶点的最短路径和路径长度，如v0到v8的最短路径中，没有v5，但D[5]=8表示v0到v5的最短路径长度为8，由P数组可得v0到v5经过的最短路径为v5←v4←v2←v1←v0。 时间复杂度为O(n²)，若求所有顶点到所有顶点的最短路径则执行n次，时间复杂度为O(n³)。 弗洛伊德(Floyd)算法 原理：$$D^0[v][w] = min {D^(-1) [v][w] , D^(-1)[v][0] + D^(-1)[0][w]}$$D^0、P^0表示初始数组，D^(-1)、P^(-1)表示经过v1搭桥处理后的数组，依次类推。 即：任意寻找一个顶点，判断以该顶点为桥任意两个顶点之间的距离是否会缩短。 代码： 123456789101112131415161718192021222324252627282930typedef int Pathmatirx[MAXVEX][MAXVEX];typedef int ShortPathTable[MAXVEX][MAXVEX];//因为求的是所有顶点到所有顶点的最短路径，所以是二维数组void ShortestPath_Floyd (MGraph G,Pathmatirx *P,ShortPathTable *D)//P[v][w]存储最短路径，D[v][w]存储带权长度&#123; for (int v = 0;v &lt; G.numVertexes;v++) &#123; for (int w = 0;w &lt; G.numVertexes;w++) &#123; (*D)[v][w] = G.arc[v][w]; (*P)[v][w] = w; &#125; &#125;//初始化操作 for (int k = 0;k &lt; G.numVertexes;k++)//k表示中转顶点 &#123; for (int v = 0;v &lt; G.numVertexes;v++)//v表示起始顶点 &#123; for (int w = 0;w &lt; G.numVertexes;w++)//w表示结束顶点 &#123; if ((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w]) &#123; (*D)[v][w] = (*D)[v][k] + (*D)[k][w]; (*P)[v][w] = (*P)[v][k];//路径设置为经过下标为k的顶点 &#125; &#125; &#125; &#125;&#125; 最终结果为： 不难发现，v0所在的列与Dijkstra算法结果完全一致。 如求v4到v7的最短路径，P[4]/[7]=3，P[3]/[7]=6，P[6]/[7]=7，故路径为v4→v3→v6→v7。(markdown中两个方括号表示链接，为了区分我在中间加了/表示二维数组。) 求最短路径的显示代码： 12345678910111213141516for (int v = 0;v &lt; G.numVertexes;v++)&#123; for (int w = v+1;w &lt; G.numVertexes;w++) &#123; printf("v%d-v%d weight: %d ",v,w,(*D)[v][w]); k = P[v][w];//获得第一个路径顶点下标 printf("path: %d",v);//打印源点 while (k != w) &#123; printf(" -&gt; %d",k);//打印路径顶点 k = P[k][w];//获得下一个路径顶点下标 &#125; printf(" -&gt; %d\n",w);//打印终点 &#125; printf("\n");&#125; 时间复杂度为O(n³)，面临需要求所有顶点到所有顶点的最短路径时比较方便。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图的最小生成树算法]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最小生成树：构成连通网的最小代价生成树。即用n-1条边将一个n个顶点的连通图连接起来，并使得权值的和最小。 最小权值和而非最短路径，即不为一笔画。 普里姆(Prim)算法定义：假设N = {P,{E}}是连通网，TE是N上最小生成树中边的集合。算法从U={u0}(u0∈V),TE={}开始。重复执行下述操作：在所有u∈U,v∈V-U的边(u,v)∈E中找一条代价最小的边(u0,v0)并入TE，同时v0并入U，直到U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树。 一句话概括：从一个顶点v0出发，找当前已纳入最小生成树的整体向外扩散的最小权值，直到所有顶点均被纳入最小生成树为止。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void MiniSpanTree_Prim (MGraph G)&#123; int adjvex[MAXVEX];//保存相关顶点下标 //adjvex[0]=1意思为边(v0,v1)在最小生成树中 int lowcost[MAXVEX];//保存相关顶点间边的权值 //lowcost[i]的值为0即下标为i的顶点加入最小生成树 lowcost[0] = 0;//v0加入生成树 adjvex[0] = 0;//初始化第一个顶点下标为0 for (int i = 1;i &lt; G.numVertexes;i++) &#123; lowcost[i] = G.arc[0][i];//将与v0顶点相连的边的权值存入 adjvex[i] = 0;//初始化都为v0的下标 &#125; //以上全为初始化操作 for (i = 1;i &lt; G.numVertexes;i++) &#123; int min = INFINITY;//初始化最小权值为∞，用65535代替 int j = 1;int k = 0; while (j &lt; G.numVertexes) &#123; if (lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min) &#123; //顶点j不在最小生成树中且整体到顶点j的所有边中最小权值小于min min = lowcost[j];//让当前权值成为最小值 k = j;//将当前最小值下标存入k &#125; j++; &#125; //该循环用于寻找当前整体向外扩散的最小值 printf("(%d,%d)",adjvex[k],k);//打印当前顶点边中权值最小边 lowcost[k] = 0;//将当前顶点纳入最小生成树 for (int j = 1;j &lt; G.numVertexes;j++) &#123; if (lowcost[j] != 0 &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123; //若下标为k的顶点各边的权值小于该顶点被加入最小生成树前整体到这些顶点的最小权值 lowcost[j] = G.arc[k][j]; adjvex[j] = k;//将下标为k的顶点存入adjvex &#125; &#125; //该循环用于将新增顶点向外扩散的权值与原整体向外扩散的权值比较后取最小权值更新lowcost数组 &#125;&#125; 由循环嵌套可知时间复杂度为O(n²)。 克鲁斯卡尔(Kruskal)算法定义：假设N = {P,{E}}是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V,{}},图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直到所有顶点都在同一连通分量上为止。 这里采用边集数组： 123456typedef struct&#123; int begin; int end; int weight;&#125;Edge; 代码： 12345678910111213141516171819202122232425262728void MiniSpanTree_Kruskal (MGraph G)&#123; int n,m; Edge edges[MAXVEX];//定义边集数组 int parent[MAXVEX];//定义一数组来判断边与边是否形成环路 //此处省略将邻接矩阵转化为边集数组且按权由小到大排序的代码 for (int i = 0;i &lt; G.numVertexes;i++) parent[i] = 0;//初始化数组为0 for (int i = 0;i &lt; G.numEdges;i++)//循环每一条边 &#123; n = Find(parent,edges[i],begin); m = Find(parent,edges[i],end); if (n != m)//若n!=m说明此边没有与现有生成树形成环路 &#123; parent[n] = m; //将此边的结尾顶点放入下标为起点的parent中，表示该顶点已经在生成树集合中 //例如parent[5]=8表示v5和v8都在生成树集合中且在同一个连通分量中 printf("(%d,%d) %d",edges[i].begin,edges[i].end,edges[i].weight); &#125; &#125;&#125;int Find (int *parent,int f)&#123; while (parent[f] &gt; 0)//将"两个数组在一个连通分量中"这一结论用数组中的空闲位置来表达 f = parent[f]; return f;&#125; 理解：例如当i = 6时parent数组为:{1,5,8,7,7,8,0,0,6},从parent[0] = 1开始可构建两条指针链： 可以认为每个连通分量只提供一个指向parent数组中值为0的项的API接口，若某条边能够形成环路，则其begin和end端经过Find函数后得到的n和m必定相等，此即为判断一条边是否满足要求的判断依据。 此算法的Find函数由边数e决定，时间复杂度为O(loge),而外面有一个for循环e次，故Kruskal算法的时间复杂度为O(eloge)。(先记下，以后再想原因) Kruskal算法主要针对边来展开，边数少时效率非常高，对于稀疏图有很大优势；Prim算法对于稠密图，即边数非常多的情况会更有优势。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图的遍历]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[图的遍历：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程称为图的遍历。 深度优先遍历(DFS)从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。 对于非连通图，只需对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问到为止。 上图中，从顶点A开始一直向右走，遇到访问过的顶点时退回，走右手第二条边，直至返回顶点A。 DFS其实就是一个递归过程，类似于一棵树的前序遍历。 邻接矩阵方式： 123456789101112131415161718192021typedef int Boolean;Boolean visit[MAX];//访问标志数组,FALSE表示该顶点未被访问void DFSTraverse (MGraph G)&#123; int i; for (i = 0;i &lt; G.numVertexes;i++) visit[i] = FALSE;//初始化 for (i = 0;i &lt; G.numVertexes;i++) if (!visit[i])//如果这个顶点没有被访问过 DFS(G,i);&#125;void DFS (MGraph G,int i)&#123; visit[i] = TRUE; printf("%c",G.vex[i]);//也可以是其他操作 for (int j = 0;j &lt; G.numVertexes;j++) if (G.arc[i][j] == 1 &amp;&amp; !visit[i]) DFS(G,j);//对被访问的顶点的邻接点递归调用&#125; 邻接表方式： 1234567891011121314151617181920212223void DFSTraverse (GraphAdjList GL)&#123; int i; for (i = 0;i &lt; GL.numVertexes;i++) visit[i] = FALSE; for (i = 0;i &lt; GL.numVertexes;i++) if (!visit[i])//如果这个顶点没有被访问过 DFS(GL,i);&#125;void DFS (GraphAdjList GL,int i)&#123; EdgeNode *p; visit[i] = TRUE; printf("%c",GL.adjList[i].data);//也可以是其他操作 p = GL.adjList[i].firstedge; while (P) &#123; if (!visit[p-&gt;adjvex]) DFS(GL,p-&gt;adjvex); p = p-&gt;next; &#125;&#125; 每个顶点都经过且仅经过一次DFS函数，因为只有该函数能设置visit数组值为TRUE 对于n个顶点e条边的图来说，邻接矩阵方式时间为O(n²),邻接表方式时间为O(n+e),故对于点多边少的稀疏图来说更适合用邻接表。 广度优先遍历(BFS)原理：每当一个元素出队列，将与该顶点相邻接的所有顶点中未被访问的顶点加入队列，加入前进行打印等处理，类似于图的层序遍历。 邻接矩阵方式： 1234567891011121314151617181920212223242526272829void BFSTraverse (MGraph G)&#123; Queue Q; InitQueue(&amp;Q);//初始化一个辅助用队列 for (int i = 0;i &lt; G.numVertexes;i++) visit[i] = FALSE; for (int i = 0;i &lt; G.numVertexes;i++) &#123; if (!visit[i]) &#123; visit[i] = TRUE; printf("%c",G.vex[i]); EnQueue(&amp;Q,i);//将此顶点入队列 while(!QueueEmpty(Q))//当前队列不为空 &#123; DeQueue(&amp;Q,&amp;i);//将队中元素出队列并赋值给i for (int j = 0;j &lt; G.numVertexes;j++) &#123; if (G.arc[i][j] == 1 &amp;&amp; !visit[j]) &#123; visit[j] = TRUE; printf("%c",G.vex[j]); EnQueue(&amp;Q,j); &#125; &#125; &#125; &#125; &#125;&#125; 只有一个DeQuene函数可以出队列，因此所有顶点均经历过该函数下方的for循环，故时间复杂度为O(n²)。 邻接表方式： 1234567891011121314151617181920212223242526272829303132void BFSTraverse (GraphAdjList GL)&#123; EdgeNode *p; Queue Q; InitQueue(&amp;Q);//初始化一个辅助用队列 for (int i = 0;i &lt; GL.numVertexes;i++) visit[i] = FALSE; for (int i = 0;i &lt; GL.numVertexes;i++) &#123; if (!visit[i]) &#123; visit[i] = TRUE; printf("%c",GL.adjList[i].data); EnQueue(&amp;Q,i);//将此顶点入队列 while(!QueueEmpty(Q))//当前队列不为空 &#123; DeQueue(&amp;Q,&amp;i);//将队中元素出队列并赋值给i p = GL.adjList[i].firstedge; while (p) &#123; if (!visit[p-&gt;adjvex]) &#123; visit[p-&gt;adjvex] = TRUE; printf("%c",GL.adjList[p-&gt;adjvex].data); EnQueue(&amp;Q,p-&gt;adjvex); p = p-&gt;next; &#125; &#125; &#125; &#125; &#125;&#125; 时间复杂度为O(n+e)。 DFS与BFS相同方式的时间复杂度相同。 深度优化遍历更适合目标比较明确，以找到目标为主要目的的情况，广度优先遍历更适合在不断扩大遍历范围时找到相对最优解的情况。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图的基本概念]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[图：由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 基本概念注意： 线性表中数据元素称为元素，树中称为结点，图中称为顶点。 在图结构中，不允许没有顶点。 在图中，任意两个顶点间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。 各种图的定义若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示。如果图中任意两个顶点间的边都是无向边，则称该图为无向图。 若顶点vi到vj之间的边有方向，则称这条边为有向边，也称为弧，用有序偶对&lt;vi,vj&gt; 来表示，其中vi称为弧尾，vj称为弧头。如果图中任意两个顶点间的边都是有向边，则称该图为有向图。 简单图：不存在顶点到其自身的边，且同一条边不重复出现。 无向完全图：任意两个顶点之间都存在边。含有n个顶点的无向完全图有n(n-1)/2条边。 有向完全图：任意两个顶点之间都存在方向互为相反的弧。含有n个顶点的有向完全图有n*(n-1)条边。 对于有n个顶点e条边的图，无向图0 &lt;= e &lt;= n(n-1)/2，有向图0 &lt;= e &lt;= n*(n-1) 有很少条边或弧的图称为稀疏图，反之称为稠密图。(相对概念) 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。这种带权的图通常称为网。 假设有两个图G1 = (V1,{E1})，G2 = (V2,{E2})，如果V2属于V1，E2属于E1，则称G2为G1的子图。 图的顶点与边间的关系对于无向图G = (V,{E}),如果边(v,v′) ∈E，则称顶点v和v′互为领接点，即v与v′相邻接。边(v,v′)依附于顶点v和v′，或者说(v,v′)与顶点v和v′相关联。顶点v的度是相关联的边的数目，记为TD(v)。 边数即为各顶点度数和的一半。 对于有向图G = (V,{E}),如果弧&lt;v,v′&gt;∈E,则称顶点v邻接到顶点v′，顶点v′邻接自顶点v。弧&lt;v,v′&gt;和顶点v，v′相关联。以顶点v为头的弧的数目称为v的入度，记为ID(v)，顶点v为尾的弧的数目称为v的出度，记为OD(v)。 TD(v) = ID(v) + OD(v) 路径的长度是路径上的边或弧的数目。 第一个顶点和最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。 连通图相关术语在无向图中，如果从顶点v到顶点v′有路径，则称v和v′是连通的。如果对于图中任意两个顶点vi，vj∈E，vi和vj都是连通的，则称G是连通图。(不一定闭合) 无向图中极大连通子图称为连通分量。注意： 要是子图 子图要是连通的 连通子图含有极大顶点数 具有极大顶点数的连通子图包含依附于这些顶点的所有边 在有向图中，如果对于每一对vi、vj∈V，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G为强连通图。有向图中的极大连通子图称做有向图的强连通分量。 连通图的生成树：一个极小的连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。 如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多余n-1条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。有n-1条边并不一定是生成树。 如果一个有向图恰有一个顶点的入度为0，其余顶点入度均为1，则是一棵有向树。 一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。 图的抽象数据类型 图的存储结构邻接矩阵用两个数组数组来表示图，一个一位数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。 无向图的边数组是一个对称矩阵。 第i行(列)的元素之和即为vi的度。 有向图： 第i行各数之和为vi的出度。 第i列各数之和为vi的入度。 网图： 结构代码12345678910typedef char VertexType;//顶点类型typedef int EdgeType;//边上权值类型#define MAXVEX 100//最大顶点数#define INFINITY 65535//用65535来代表∞typedef struct&#123; VertexType vexs[MAXVEX];//顶点表 EdgeType arc[MAXVEX][MAXVEX];//邻接矩阵，可看作边表 int numVertexes,numEdges;//当前顶点数和边数&#125;MGraph; 创建邻接矩阵123456789101112131415161718void CreateMGraph (MGraph *G)&#123; int i,j,k,w; printf("输入顶点数和边数:\n"); scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); for (i = 0;i &lt; G-&gt;numVertexes;i++)//建立顶点表 scanf("%d",&amp;G-&gt;vexs[i]); for (i = 0;i &lt; G-&gt;numEdges;i++) for (j = 0;j &lt; G-&gt;numVertexes;j++) G-&gt;arc[i][j] = INFINITY;//邻接矩阵初始化 for (k = 0;k &lt; G-&gt;numEdges;k++) &#123; printf("输入边(vi,vj)上的下标i，下标j和权数w：\n"); scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w); G-&gt;arc[i][j] = w; G-&gt;arc[j][i] = G-&gt;arc[i][j];//无向图矩阵对称 &#125;&#125; 时间复杂度为O(n+n²+e) 对于边数相对顶点较少的图，邻接矩阵对存储空间比较浪费。 邻接表数组与链表相结合的存储方法。 顶点用一维数组存储，每个数据元素还存储指向第一个邻接点的指针。 每个顶点的所有邻接点构成一个线性表，用单链表存储。(有向图为出边表) 对于有向图还可以建立一个逆邻接表，即入边表： 对于带权值的网图，可以在边表结点中增加一个weight数据域： 结构代码1234567891011121314151617181920typedef char VertexType;typedef int EdgeType;typedef struct EdgeNode//边表结点&#123; int adjvex;//邻接点域，存储该顶点对应的下标 EdgeType weight;//用于存储权值 struct EdgeNode *next;//链域，指向下一个邻接点&#125;EdgeNode;typedef struct VertexNode//邻接表结点&#123; VertexType data; EdgeNode *firstedge;&#125;VertexNode,AdjList[MAXVEX];typedef struct&#123; AdjList adjList;//上机已证实可以这么用 int numVertexes,numEdges;&#125;GraphAdjList; 创建邻接表12345678910111213141516171819202122232425262728void CreateALGraph (GraphAdList *G)&#123; int i,j,k; EdgeNode *e; printf("输入顶点数和边数:\n"); scanf("%d,%d",&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges); for (i = 0;i &lt; G-&gt;numVertexes;i++) &#123; scanf("%d",&amp;G-&gt;adjList[i].data);//输入顶点信息 G-&gt;adjList[i].firstedge = NULL;//将边表置为空表 &#125; for (k = 0;k &lt; G-&gt;numEdges;k++) &#123; printf("输入边(vi,vj)上的下标i，下标j和权数w：\n"); scanf("%d,%d,%d",&amp;i,&amp;j,&amp;w); e = (EdgeNode*)malloc(sizeof(EdgeNode)); e-&gt;adjvex = j; e-&gt;weight = w; e-&gt;next = G-&gt;adjList[i].firstedge; G-&gt;adjList[i].firstEdge = e; e = (EdgeNode*)malloc(sizeof(EdgeNode)); e-&gt;adjvex = i; e-&gt;weight = w; e-&gt;next = G-&gt;adjList[j].firstedge; G-&gt;adjList[j].firstEdge = e; &#125;&#125; 时间复杂度为O(n+e) 十字链表将邻接表与逆邻接表结合。优化有向图的邻接表。 tailvex：弧起点在顶点表的下标。 headvex：弧终点在顶点表的下标。 headlink：入边表指针域，指向终点相同的下一条边。(竖着指) taillink：出边表指针域，指向起点相同的下一条边。(与邻接表相同) 十字链表的好处是把邻接表和逆邻接表整合到了一起，既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的入度和出度。 除了结构复杂了一点外，其实创建图算法的时间复杂度和邻接表相同。 邻接多重表优化无向图的邻接表。使之易于对边操作。 ilink：指向依附顶点ivex的下一条边。 jlink：指向依附顶点jvex的下一条边。 ilink和jlink指向的位置一定要与其本身依附的顶点的值相同。 邻接多重表与邻接表的区别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。如果要删除(v0,v2)这条边，只需将右图中⑥⑨的链接指向改为^即可。 边集数组两个一维数组组成，一个存储顶点信息，一个存储边的信息，这个边数组每个元素由一条边的起点下标、终点下标和权值组成。 它更适合对边依次进行操作，而非对顶点进行操作。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树（三）]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线索二叉树 定义给没有左孩子的结点的左指针域赋值指向该结点前驱的指针，给没有右孩子的结点的右指针域赋值指向该结点后继的指针，这种指向前驱和后继的指针称为线索，相应的二叉树称为线索二叉树。 产生原因：想要知道某结点的前驱后继是谁时不用再次遍历，节约了时间；空指针域得以利用，节省了空间。 以下均为中序遍历 线索二叉树相当于把一棵二叉树变成了一个双向链表。 把对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化 为了区分孩子指针和前驱后继指针，每个结点再增设两个标志域，只存放布尔型变量： ltag为0时指向该结点的左孩子，为1时指向该结点的前驱 rtag为0时指向该结点的右孩子，为1时指向该结点的后继 结构代码123456789typedef enum &#123;Link,Thread&#125; PointerTag;//Link==0表示指向左右孩子的指针，Thread==1表示指向前驱或后继的指针typedef struct BitThrNode&#123; TElemType data; struct BitThrNode *lchild,*rchild; PointerTag LTag; PointerTag RTag;//左右标志&#125;BiThrNode,*BiThrTree; 线索化的过程就是在遍历过程中修改空指针的过程。 中序遍历线索化代码1234567891011121314151617181920BiThrTree pre;//全局变量，始终指向刚刚访问过的结点void InThreading (BiTheTree p)&#123; if (p) &#123; InThreading (p-&gt;lchild);//递归左子树线索化 if (!p-&gt;lchild)//没有左孩子 &#123; p-&gt;ltag = Thread;//前驱线索 p-&gt;lchild = pre;//左孩子指向前驱 &#125; if (!pre-&gt;rchild)//前驱没有右孩子 &#123; pre-&gt;rtag = Thread;//后继线索 pre-&gt;rchild = p;//前驱的右孩子指针指向后继(p) &#125; pre = p;//保持pre指向p的前驱 InThreading (p-&gt;rchild);//递归右子树线索化 &#125;&#125; 可以加一个头结点，lchild指针域的指针指向二叉树的根结点；rchild指针域的指针指向中序遍历时访问的最后一个结点；二叉树中序遍历第一个结点的lchild指针域的指针和最后一个结点的rchild指针域的指针均指向头结点。这样定义的好处是既可以从第一个结点开始向后遍历，又可以从最后一个结点开始向前遍历(相当于循环链表) 疑问：前驱和后继指针在度为2的结点处不连续，走不通 回答：假设某个结点度为2，它的左子树通过后继指针走到尽头后即访问该结点，疑问在于此时此刻没有后继指针了无法继续向后，实际上无论如何下一步都会进入该结点的右子树，故下一步找到其右子树进行中序遍历的第一个结点即可，具体见下代码： 遍历带有头结点的线索二叉树代码1234567891011121314151617181920//T指向头结点，中序遍历二叉线索链表表示二叉树TStatus InOrderTraverse_Thr (BiThrTree T)&#123; BiThrTree p; p = T-&gt;lchild;//p指向根结点 while (p != T)//空树或遍历结束时，p == T &#123; while (p-&gt;LTag == Link) //当LTag=0时循环到中序序列的第一个结点 p = p-&gt;lchild; printf("%c",p-&gt;data);//也可以是其他操作 while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T) &#123; p = p-&gt;rchild; printf("%c",p-&gt;data); &#125; p = p-&gt;rchild;//当结点存在右子树时进入右子树根 &#125; return OK;&#125; 如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱或后继，则采用线索二叉链表的存储结构是一种不错的选择。 树、二叉树、森林的转换树转化为二叉树 加线。在所有兄弟结点间加一条连线。 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。 层次调整。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来是结点的右孩子 森林转换为二叉树 把每个树转换为二叉树。 第一棵树不动，从第二棵树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有二叉树连接起来后就得到了由森林转换来的二叉树。(从最后一棵开始依次来) 二叉树转换为树 加线。若某结点的左孩子结点存在，则将左孩子的n个右孩子都作为此结点的孩子，用线连接起来。 去线。删除原二叉树中所有结点与其右孩子结点的连线。 层次调整。 二叉树转换为森林判断一棵二叉树能转换成一棵树还是森林，只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。 从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查，直到所有右孩子连线都删除为止，得到分离的二叉树。 将每棵二叉树转换为树即可。 树与森林的遍历树的遍历： 方法一：先根遍历树，即先访问树的根结点，再依次先根遍历根的每棵子树。 方法二：后根遍历，即先依次后根遍历每棵子树，再访问根结点。 森林的遍历： 前序遍历：先访问森林中第一棵树的根结点，再依次先根遍历根的每棵子树，再依同样的方式遍历除第一棵树的剩余树构成的森林。 后序遍历：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，再访问根结点，再依同样的方式遍历除第一棵树的剩余树构成的森林。 树和森林的前序遍历和二叉树的前序遍历结果相同，树和森林的后序遍历和二叉树的中序遍历结果相同。 当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现。 赫夫曼树及其应用从树中的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。 树的路径长度就是从树根到每一个结点的路径长度之和。 如果考虑带权的结点，结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。 树的带权的路径长度为树中所有叶子结点的带权路径长度之和。 赫夫曼树：带权路径长度WPL最小的二叉树。 求法： 归纳： 根据给定的n个权值{w1,w2,…,wn}构成n棵二叉树的集合F = {T1,T2,…,Tn},其中每棵二叉树T1中只有一个带权为w1的根结点，其左右子树均为空。 在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且新的二叉树的结点的权值为其左右子树上根结点的权值之和。 在F中删除这两棵树，同时将新得到的二叉树加入F中。 重复2,3步骤，直到F只含一棵树为止，这棵树便是赫夫曼树。 赫夫曼树创建目的是解决当年远距离通信(主要是电报)的数据传输的最优化问题。 详见大话数据结构P205 赫夫曼编码：一般地，设需要编码的字符集为{d1,d2,…,dn}，各个字符在电文中出现的次数或概率的集合为{w1,w2,…,wn},以d1,d2,…,dn作为叶子结点，以w1,w2,…,wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树（二）--二叉树]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89--%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的定义：二叉树是n(n &gt;= 0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 基本概念特点： 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。 左右子树是有顺序的，次序不能任意颠倒。 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 三个结点的树有两种形态，三个结点的二叉树有五种形态 五种基本形态： 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 特殊二叉树斜树所有结点都只有左子树的树叫做左斜树，所有结点都只有右子树的树叫做右斜树，两者统称斜树。 每一层只有一个结点，结点的个数与二叉树深度相同。 满二叉树所有分支结点都存在左右子树，且所有叶子结点都在同一层上的二叉树。 特点： 叶子只能出现在最下层 非叶子结点的度一定为2 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多 完全二叉树对一棵具有n个结点的二叉树按层序编号，如果编号为i(1 &lt;= i &lt;= n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 特点： 叶子结点只能出现在最下两层 最下层的叶子一定集中在左部连续位置 倒数第二层若有叶子结点，则一定都在右部连续位置 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况 同样结点数的二叉树，完全二叉树深度最小 二叉树的性质 在二叉树的第i层上至多有2^(i-1)个结点(i &gt;= 1) 深度为k的二叉树至多有2^k - 1 个结点(k &gt;= 1) 对任意一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1 原因：分支总数 = 结点总数 - 1 ​ n1 + 2*n2 = n0 + n1 + n2 -1 ​ 故n0 = n2 + 1 具有n个结点的完全二叉树的深度为[log₂n]+1([x]表示不大于x的最大整数) 如果对一棵有n个结点的完全二叉树(其深度为[log₂n]+1)的结点按层序编号，对任一结点i (i &lt;= i &lt;= n)有： 如果i = 1，则结点i是二叉树的根，无双亲；如果i &gt; 1，则其双亲是结点[i/2] 如果2i &gt; n，则i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i 如果2i+1 &gt; n，则i无右孩子；否则其左孩子是结点2i+1 若一个偶数结点下一位奇数结点存在，则该奇数结点为该偶数结点的右兄弟 二叉树的存储结构顺序存储结构对于一般二叉树，尽管层次编号不能反映逻辑关系，但可以将其按完全二叉树编号，把不存在的结点设置为”^”，依次存入数组中。 极端情况下，右斜树将造成存储空间极大浪费。(k个结点要分配2^k - 1个存储单元空间) 顺序存储结构一般只用于完全二叉树 二叉链表二叉树每个结点设计为一个数据域和两个指针域。 结构代码： 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild,*rchild;//左右孩子指针&#125;BiTNode,*BiTree; 也可以增加一个指向双亲的指针构成三叉链表。 求二叉树高度12345678910111213int PostOrderGetHeight(BiTree T)&#123; int HL,HR,MaxH; if(T) &#123; HL = PostOrderGetHeight(BT-&gt;Left);//求左子树的深度 HR = PostOrderGetHeight(BT-&gt;Right);//求右子树的深度 MaxH =（HL &gt; HR）? HL : HR;//取左右子树较大的深度 return (MaxH+1);//返回树的深度 &#125; else return 0;//空树深度为0&#125; ​ ~~via文盲 遍历二叉树二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。(从根结点出发并不意味着先访问根结点) 前序遍历(先访问根结点)若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。ABDGHCEIF 结构代码： 12345678void PreOrderTraverse (BiTree T)&#123; if (T-&gt;NULL) return; printf("%c",T-&gt;data);//可以改为其他对结点的操作 PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild);&#125; 中序遍历(中间访问根结点)若树为空，则空操作返回，否则从根结点开始，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。GDHBAEICF 结构代码： 12345678void InOrderTraverse (BiTree T)&#123; if (T-&gt;NULL) return; InOrderTraverse(T-&gt;lchild); printf("%c",T-&gt;data);//可以改为其他对结点的操作 InOrderTraverse(T-&gt;rchild);&#125; 非递归表示法(使用堆栈)~~via文盲： 123456789101112131415161718void InOrderTraverse (BiTree T)&#123; Stack S = CreatStack(MaxSize);//创建并初始化堆栈 while （T || !IsEmpty(S)） &#123; while (T) &#123; Push(S,T);//压栈 T = T-&gt;Left;//从树左边开始 &#125; if (!IsEmpty(S)) &#123; T = Pop(S);//结点弹出堆栈 printf("%c",T-&gt;Data);//输出结点 T = T-&gt;Right;//转向右子树 &#125; &#125;&#125; 后序遍历(最后访问根结点)若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。GHDBIEFCA 结构代码： 12345678void PostOrderTraverse (BiTree T)&#123; if (T-&gt;NULL) return; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); printf("%c",T-&gt;data);//可以改为其他对结点的操作&#125; 层序遍历若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。ABCDEFGHI 使用队列实现~~via文盲： 12345678910111213141516void LevelOrderTraverse(BiTree T)&#123; Queue Q;//创建队列 if(!T) return;//是空树则直接返回 AddQ(Q,T); while(!IsEmptyQ(Q)) &#123;//循环，直至队列为空 T = DelateQ(Q); printf("%d\n",T-&gt;Data);//访问取出队列的结点 if(T-&gt;Left) AddQ(Q,T-&gt;Left); if(T-&gt;Right) AddQ(Q,T-&gt;Right); &#125;&#125; 二元运算表达树及其遍历三种遍历得到不同的访问结果： 先序遍历得到前缀表达式。 中序遍历得到中缀表达式：但是中缀表达式可能由于优先级不同，出现问题。 —- 如何解决？输出左子树之前加左括号，输出右子树之后加右括号。 后序遍历得到后缀表达式。 ​ ~~via文盲 计算机只会处理线性序列，这些遍历方法其实都是在把树中的结点变成某种有意义的线性序列，给程序的实现带来好处。 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。 已知前序遍历序列和后序遍历序列，不能确定一棵二叉树。 二叉树的建立扩展二叉树：将二叉树每个结点的空指针引出一个虚结点，其值为一个特定值(如#)，这种处理后的二叉树为原二叉树的扩展二叉树。 扩展二叉树可以做到一个遍历序列确定一棵二叉树。(确定某一个结点有几个孩子，是否为叶子结点等) 假设用前序遍历生成一个结点均为字符的二叉树： 用键盘输入：AB#D##C## 123456789101112131415161718192021//按前序输入二叉树中结点的值(一个字符)//#表示空树，构造二叉链表表示二叉树Tvoid CreateBiTree (BiTree *T)&#123; TElemType ch; scanf("%c",&amp;ch); if (ch == '#') *T = NULL;//空结点 else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if (!*T) exit(OVERFLOW);//内存已炸 else &#123; *T-&gt;data = ch;//生成根结点 CreateBiTree (&amp;(*T)-&gt;rchild);//构造左子树 CreateBiTree (&amp;(*T)-&gt;lchild);//构造右子树 &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树（一）]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[树：n(n &gt;= 0)个结点的有限集。n = 0时为空树。在任意一棵非空树中： 有且仅有一个特定的称之为根的结点。 当n &gt; 1时，其余结点可分为m(m &gt; 0)个互不相交的有限集T1、T2、…、Tm，其中每一个集合本身又是一棵树，并且称为根的子树。 基本概念对树的定义还需强调两点： n &gt; 0时根结点是唯一的，不可能存在多个根结点。 m &gt; 0时，子树的个数没有限制，但他们一定是互不相交的。 结点分类结点拥有的子树数称为结点的度。 度为0的结点称为叶子结点或终端结点。 度不为0的结点称为分支结点。(除根结点外，分支结点也称为内部结点) 树的度是树内各结点的度的最大值。 结点间的关系结点的子树的根称为该结点的孩子。该结点称为孩子的双亲。 同一双亲的孩子间互称兄弟。 结点的祖先是从根到该结点所经过分支上的所有结点。 以某结点为根的子树中的任一结点都称为该结点的子孙。 其双亲在同一层的结点互为堂兄弟。 其他概念结点的层次从根开始定义起，根为第一层，根的孩子在第二层。 树中结点的最大层次称为树的深度或高度。 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林是m(m &gt;= 0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。 树的抽象数据类型打星号内容为发博客时存有疑惑 树的存储结构双亲表示法假设一组连续空间存储树的结点。同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。 结构代码： 123456789101112#define MAX_TREE_SIZE 100typedef int TElemType;typedef struct PTNode&#123; TElemType data;//结点数据 int parent;//双亲位置&#125;PTNode;typedef struct&#123; PTNode nodes[MAX_TREE_SIZE];//结点数组 int r,n;//根的位置和结点数&#125;PTree; 我们约定根结点的双亲位置为-1。 可以扩展出长子域或右兄弟域，存储结构的设计非常灵活。 多重链表表示法每个结点有多个指针域，每个指针指向一棵子树的根结点。 方法一： ​ 指针域的个数等于树的度。 ​ 当树中各结点的度相差很大时浪费空间。 方法二： ​ 每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数。 ​ 空间利用率高，但各个结点结构不同加上要维护结点的度的数值，运算时间上有损耗。 孩子表示法把每个结点的孩子结点排列起来，以单链表为存储结构，则n个结点有n个孩子链表，如果是叶子结点则单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构存放进一个一位数组中。 结构代码： 12345678910111213141516#define MAX_TREE_SIZE 100typedef struct CTNode//孩子结点&#123; int child; struct CTNode *next;&#125; *ChildPtr;typedef struct//表头结构&#123; TElemType data; ChildPtr firstchild;&#125;CTBox;typedef struct//树结构&#123; CTBox nodes[MAX_TREE_SIZE]； int r,n;//根的位置和结点数&#125;CTree; 难以找到某个结点的双亲，可以改进至双亲孩子表示法: 孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 结构代码： 12345typedef struct CSNode&#123; TElemType data; struct CSNode *firstchild,*rightsib;&#125;CSNode,*CSTree; 同样难以找到双亲，也可以再加个parent指针。 这个表示法最大的好处是把一棵复杂的树变成了一棵二叉树。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[串/KMP模式匹配算法]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%B8%B2-KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列：只允许在一端进行插入操作，另一端进行删除操作的线性表。 队列是一种先入先出(First In First Out)的线性表，简称FIFO。 允许插入的一端称为队尾，允许删除的一端称为队头。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[栈的应用--逆波兰表示法]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈：限定仅在表尾进行插入和删除操作的线性表。 栈的定义允许插入和删除的一段称为栈顶，另一端称为栈底。 不含任何数据元素的栈称为空栈。 后入先出(Last In First Out)线性表，简称LIFO结构。 栈的插入操作，叫做进栈，也称压栈、入栈。 栈的删除操作，叫做出栈，也称弹栈。 3个元素1，2，3依次进栈，有5种可能的出栈次序： 1、2、3进，再3、2、1出，次序为321 1进，1出，2进，2出，3进，3出，次序为123 1进，2进，2出，1出，3进，3出，次序为213 1进，1出，2进，3进，3出，2出，次序为132 1进，2进，2出，3进，3出，1出，次序为231 肯定不会出现312的情况，因为若3先出栈，则3必曾进过栈，则1、2已经进栈了，则2在1之上，不可能1先出栈 栈的抽象数据类型 栈的顺序存储结构定义一个栈顶指针top来表示栈顶在数组中的位置 结构代码123456typedef int SElemType;typedef struct&#123; SElemType data[MAXSIZE]; int top;&#125;SqStack; 进栈操作123456789//插入元素e为新的栈顶元素Status Push (SqStack *S,SElemType e)&#123; if (S-&gt;top == MAXSIZE-1)//是否栈满 return ERROR; S-&gt;top++; S-&gt;data[S-&gt;top] = e;//将新插入的指针赋值给栈顶空间 return OK;&#125; 出栈操作123456789//若栈非空，则删除栈顶元素，用e返回其值Status Pop (SqStack *S,SElemType *e)&#123; if (S-&gt;top == -1)//空栈top值为-1 return ERROR; *e = S-&gt;data[S-&gt;top]; S-&gt;top--; return OK;&#125; 时间复杂度均为O(1) 两栈共享空间一个栈的栈底为数组下标为0处，另一个的栈底为数组下标为n-1处 当两个指针间相差1时，即top1 + 1 = top2时为栈满(栈1满时，top1 = n-1,top2 = n;栈2满时，top1 = -1，top2 = 0) 结构代码123456typedef struct&#123; SElemType data[MAXSIZE]; int top1; int top2;&#125;SqDoubleStack; 进栈操作12345678910Status Push (SqDoubleStack *S,SElemType e,int stackNumber)&#123; if (S-&gt;top1+1 == S-&gt;top2)//栈已满，不能再push新元素 return ERROR; if (stackNumber == 1)//栈1有元素进栈 S-&gt;data[++S-&gt;top1] = e; else if (stackNumber == 2)//栈2有元素进栈 S-&gt;data[--S-&gt;top2] = e; return OK;&#125; 出栈操作12345678910111213141516Status Pop (SqDoubleStack *S,SElemType *e,int stackNumber)&#123; if (stackNumber == 1) &#123; if (S-&gt;top1 == -1) return ERROR;//栈1为空栈 *e = S-&gt;data[S-&gt;top1--]; &#125; else if (stackNumber == 2) &#123; if (S-&gt;top2 == n) return ERROR;//栈2为空栈 *e = S-&gt;data[S-&gt;top2++]; &#125; return OK;&#125; 通常当两个栈具有相同数据类型且空间需求有相反关系时使用这样的数据结构 栈的链式存储结构通常将栈顶放在单链表的头部，头指针充当栈顶指针，不需要头结点。 结构代码1234567891011typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr;typedef struct LinkStack&#123; LinkStackPtr top; int count;//结点总数&#125;LinkStack; 进栈操作12345678910Status Push (Linkstack *S,SElemType e)&#123; LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data = e; s-&gt;next = S-&gt;top; S-&gt;top = s; S-&gt;count++; return OK;&#125; 出栈操作12345678910111213Status Pop (LinkStack *S;SElemType *e)&#123; LinkStackPtr p; if (StackEmpty(*S)) return ERROR; *e = S-&gt;top-&gt;data; p=S-&gt;top;//将栈顶结点赋值给p S-&gt;top = S-&gt;top-&gt;next;//栈顶指针下移一位 free(p); S-&gt;count--; return OK;&#125; 如果栈的使用过程中元素变化不可预料，那么最好用链栈，反之若变化在可控范围内，则最好用顺序栈 栈的引入简化了程序设计问题，划分了不同层次，使思考范围缩小，更加聚焦于我们要解决的问题的核心。 栈的应用–递归：在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中；在退回阶段，位于栈顶的局部变量、参数、和返回地址被弹出，用于返回调用层次中执行代码的剩余部分，也就是恢复了调用状态。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表：零个或多个数据元素的有限序列。 线性表的定义若将线性表记为(A1,…,Ai,…,An),则表中Ai-1领先于Ai，Ai领先于Ai+1，称Ai-1是Ai的直接前驱元素，Ai+1是Ai的直接后继元素，当i = 1,2,…,n-1时，Ai有且仅有一个直接后继，当i = 2,3,…,n时，Ai有且仅有一个直接前驱。 线性表元素个数n(n &gt;= 0)定义为线性表的长度，当n = 0时，称为空表。 在较复杂的线性表中，一个数据元素可以由若干数据项组成。 线性表的抽象数据类型 上述操作都是基本操作，实际问题中涉及线性表的更复杂的操作可以由这些基本操作的组合来完成。例如： 12345678910111213141516//将所有在线性表Lb中但不在La中的数据元素插入到La中void union(List *La,List Lb)//List代指所有线性表，不是具体的一种结构&#123; int La_len,Lb_len; ElemType *e;//声明指向与La和Lb相同的数据元素e的指针 La_len = ListLength(La)； Lb_len = ListLength(Lb); for (int i = 1;i &lt;= Lb_len;i++) &#123; GetELem(Lb,i,*e);//取Lb中第i个元素赋值给e if (!LocateElem(La,*e))//La中不存在和e相同的数据元素 ListInsert(La,++La_len,*e);//插入到La的末尾 &#125;&#125;//在一些指针方面对书上代码做了些改动，若有大佬发现问题欢迎提出 线性表的顺序存储结构线性表的顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素。 结构代码123456#define MAXSIZE 20typedef int ElemType;typedef struct &#123; ElemType deta[MAXSIZE];//数组存储数据元素，最大值为MAXSIZE int length;//线性表当前长度&#125;SqList; 描述顺序存储结构三个属性： 存储空间的起始位置：数组data的存储位置就是存储空间的存储位置 线性表的最大存储容量：数组长度MAXSIZE 线性表的当前长度：length 数组长度是存放线性表的存储空间的长度，线性表的长度是线性表中数据元素的个数(变化的)，在任意时刻，线性表的长度应小于等于数组长度 假设每个数据元素占用c个存储单元，则线性表中第i+1个数据元素的存储位置和第i个元素的存储位置满足下列关系(LOC表示获得存储位置的函数) ​ LOC(Ai+1) = LOC(Ai) + c 因此 ​ LOC(Ai) = LOC(A1) + (i-1) * c 通过这个公式可以随时算出线性表中任意位置的地址，对于计算机来说都是相等的时间，存储性能为O(1),我们把具有这一特点的存储结构称为随机存取结构。 获得元素操作1234567891011121314#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//函数的类型，其值是函数结果状态代码，如OK等//初始条件：顺序线性表L已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果：用e返回L中第i个数据元素的值Status GetElem (SqList L,int i,ElemType *e)&#123; if (L.length = 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = L.data[i-1]; return OK;&#125; 插入元素操作12345678910111213141516//初始条件：顺序线性表已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1Status ListInsert (SqList *L,int i,ElemType e)&#123; if (L-&gt;length == MAXSIZE || i &lt; 1 || i &gt; L-&gt;length+1) return ERROR; if (i &lt;= L-&gt;length)//插入的位置不在表尾 &#123; for (int k = L-&gt;length-1;k &gt;= i-1;k--) L-&gt;data[k+1] = L-&gt;data[k]; //将要插入位置之后的数据元素向后移动一位 &#125; L-&gt;data[i-1] = e; L-&gt;length++; return OK;&#125; 删除元素操作12345678910111213141516//初始条件：顺序线性表已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果：删除L第i个数据元素，并用e返回其值，L的长度减1Status ListDelete (SqList *L;int i;ElemType *e)&#123; if (L-&gt;length = 0 || i &lt; 1 || i &gt; L-&gt;length ) return ERROR; *e = L-&gt;data[i-1]; if (i &lt; L-&gt;length)//删除的不是最后位置 &#123; for (int k = i;k &lt; L-&gt;length;k++) L-&gt;data[k-1] = L-&gt;data[k]; //将删除位置后继元素前移 &#125; L-&gt;length--; return OK;&#125; 插入或删除时平均时间复杂度为O(n) 顺序存储结构的优缺点优点： 无需为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的”碎片” 线性表的链式存储结构存储数据元素信息的域称为数据域，存储直接后继元素位置的域称为指针域，指针域中存储的信息称作指针或链，这两部分组织数据元素Ai的存储映像，称作结点 单链表：每个结点中只包含一个指针域 头指针：链表第一个结点的存储位置(无论链表是否为空，头指针均不为空，是链表的必须元素。若链表有头结点，则是指向头结点的指针) 头结点：单链表第一个结点之前的结点，其指针域存储指向第一个结点的指针(实现了在第一个元素结点前插入结点和删除第一个结点的操作与其他结点操作的统一，不是链表的必须元素) 结构代码123456typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList; 以下代码均假定头结点存在。 获取元素操作123456789101112131415161718//初始条件：顺序线性表L已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果：用e返回L中第i个数据元素的值Status GetElem (SqList L,int i,ElemType *e)&#123; int j = 1; LinkList p; p = L-&gt;next;//让p指向链表第一个结点(非头结点) while (p &amp;&amp; j &lt; i)//p不为空或计数器j还没等于i时，循环继续 &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i) return ERROR;//第i个元素不存在 *e = p-&gt;data; return OK;&#125; 单链表的插入123456789101112131415161718192021//初始条件：顺序线性表已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果：在L中第i个结点之前插入新的数据元素e，L的长度加1Status ListInsert (SqList *L,int i,ElemType e)&#123; LinkList p,s; int j = 1; p = L-&gt;next; while (p &amp;&amp; j &lt; i-1)//寻找第i-1个结点 &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i) return ERROR;//第i个元素不存在 s = (LinkList)malloc(sizeof(Node)); s-&gt;data = e; s-&gt;next = p-&gt;next;//将p的后继结点赋值给s的后继 p-&gt;next = s;//将s赋值给p的后继 return OK;&#125; 单链表的删除123456789101112131415161718192021//初始条件：顺序线性表已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果：删除L第i个数据元素，并用e返回其值，L的长度减1Status ListDelete (SqList *L;int i;ElemType *e)&#123; int j = 1; LinkList p,q; p = L-&gt;next; while (p &amp;&amp; j &lt; i-1)//寻找第i-1个结点 &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i) return ERROR;//第i个元素不存在 q = p-&gt;next;//q指向第i个结点 p-&gt;next = q-&gt;next;//将q的后继结点赋值给p的后继结点 *e = q-&gt;data; free(q); return OK;&#125; 单链表的整表创建(头插法)12345678910111213141516//随机产生n个元素的值，建立带头结点的单链表Lvoid CreateListHead(LinkList *L,int n)&#123; LinkList p; srand(time(0));//初始化随机种子 *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL;//建立一个带头结点的单链表 for (int i = 0;i &lt; n;i++) &#123; p = (LinkList)malloc(sizeof(Node));//生成新结点 p-&gt;data = rand()%100+1；//随机生成100以内的数字 p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p;//插入到表头 &#125;&#125; 单链表的整表创建(尾插法)12345678910111213141516void CreateListHead(LinkList *L,int n)&#123; LinkList p,r; srand(time(0));//初始化随机种子 *L = (LinkList)malloc(sizeof(Node)); r = *L;//r为指向尾部的结点 for (int i = 0;i &lt; n;i++) &#123; p = (LinkList)malloc(sizeof(Node)); p-&gt;data = rand()%100+1； r-&gt;next = p; r = p; &#125; r-&gt;next = NULL;//表示当前链表结束&#125; 单链表的整表删除123456789101112131415161718192021//初始条件：顺序线性表L已经存在//操作结果：将L重置为空表Status ClearList (LinkList *L)&#123; LinkList p,q; p = (*L)-&gt;next;//p指向第一个结点 while (p)//没到表尾 &#123; q = p; p = p-&gt;next; free(q); /*书上代码： q = p-&gt;next; free(p); p = q; */ &#125; (*L)-&gt;next = NULL; return OK;&#125; 单链表结构与顺序存储结构的优缺点 结论： 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构；若需要频繁插入与删除时，宜采用单链表结构。 当线性表中元素个数变化较大或根本不知道有多大时，最好采用单链表结构，而若事先知道线性表大致长度，则顺序存储结构效率高很多。 其他链表静态链表用数组描述的链表(给没有指针的高级语言设计的一种实现单链表能力的方法) 优点： 在插入和删除操作时，只需修改游标，不需要移动元素，从而改进了在顺序存储结构中插入和删除操作需要移动大量元素的缺点 缺点： 没有解决连续存储分配带来的表长难以确定的问题 失去了顺序存储结构随机存取的特性 (具体代码日后没事再更，详情可见大话数据结构P71页) 循环链表将单链表中终端结点的指针端由空结点改为头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。 循环链表解决了一个很麻烦的问题，即如何从当中一结点出发，访问到链表全部结点。 单链表中头指针访问第一个结点需要O(1)时间，访问最后一个结点需要O(n)时间 循环链表中若设置尾指针，则查找终端结点与开始结点的时间复杂度均为O(1) 用尾指针非常容易合并两个循环链表 双向链表在单链表的每个结点中，再设置一个指向其前驱结点的指针域 结构代码： 123456typedef struct DulNode&#123; ElemType data; struct DulNode *prior; struct DulNode *next;&#125;DulNode, *DulLinkList; p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next 在p与p-&gt;next之间插入结点s： 1234s-&gt;next = p-&gt;next;s-&gt;prior = p;p-&gt;next-&gt;prior = s;p-&gt;next = s; 先搞定s的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继 删除结点p： 123p-&gt;prior-&gt;next = p-&gt;next;p-&gt;next-&gt;prior = p-&gt;prior;free(p);]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法基础]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表现一个或多个操作。 算法的特性 输入输出：算法具有零个或多个输入，至少有一个或多个输出。 有穷性：指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成。（譬如运行二十年结束的算法就不可行） 确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。（算法在一定条件下，只有一条执行路径，相同的输入只能有唯一输出的结果） 可行性：算法每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。（算法可以转换为程序上机运行，并能得到正确结果） 算法的设计要求 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能得到问题的正确答案。 四个层次： 1.算法程序没有语法错误。 2.算法程序对于合法的输入数据能够产生满足要求的输出结果。 3.算法程序对于非法的输入数据能够得到满足规格说明的结果。 4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。 一般情况下把层次3作为一个算法是否成功的标准 ​ 可读性：算法设计的另一目的是为了便于阅读、理解和交流。 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果 时间效率高和存储量低 （存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序所占用的内存或外部存储空间） 算法效率的度量方法 事后分析法(不科学，不准确) 事前分析估算法 一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少 算法的时间复杂度：大O记法推导大O阶 用常数1取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶存在且不是1，则去除与这个项相乘的常数。 常数阶 O(1)123int sum = 0; //执行一次sun = (1+n)*n/2; //执行一次printf("%d",sum); //执行一次 线性阶 O(n)1234for (int i = 0;i &lt; n;i++)&#123; //时间复杂度为O(1)的序列&#125; 对数阶 O(logn)123456int count;while (count &lt; n)&#123; count = count * 2; //时间复杂度为O(1)的序列&#125; 平方阶 O(n²)12345678int i,j;for (i = 0;i &lt; n;i++)&#123; for (j = 0;j &lt; n;j++) &#123; //时间复杂度为O(1)的序列 &#125;&#125; 1234567891011121314int i,j;for (i = 0;i &lt; n;i++)&#123; for (j = i;j &lt; n;j++) &#123; //时间复杂度为O(1)的序列 &#125;&#125;/* 总执行次数 = n+(n-1)+(n-2)+...+1 = (n+1)*n/2 = n²/2 + n/2 时间复杂度仍为O(n²)*/ 123456789101112131415161718192021222324void function(int count)&#123; int j; for (j = count;j &lt; n;j++) &#123; //时间复杂度为O(1)的序列 &#125;&#125;n++; //执行次数为1function(n); //执行次数为nint i,j;for(i = 0;i &lt; n;i++) //执行次数为n²&#123; functon(i);&#125;for (i = 0;i &lt; n;i++) //执行次数为n*(n+1)/2&#123; for (j = i;j &lt; n;j++) &#123; //时间复杂度为O(1)的序列 &#125;&#125;//时间复杂度仍为O(n²) 常见时间复杂度所消耗时间排序O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!) &lt; O(nⁿ) 其他最坏运行时间是一种最重要的需求，除非特殊指定，一般提到的运行时间都是指最坏情况下的运行时间。 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。 若算法执行时所需的辅助空间相对于数据量而言是一个常数，则称此算法为原地工作，空间复杂度为O(1).]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据结构：一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关操作 的学科。是相互之间存在一种或多种关系的数据元素的集合。 程序设计 = 数据结构 + 算法 数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 可以输入到计算机中 能被计算机程序处理 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据元素是数据结构中建立数据模型的着眼点 数据项：一个数据元素可以有若干数据项组成。 数据项是数据不可分割的最小单位 数据对象：性质相同的数据元素的集合，是数据的子集。 逻辑结构：数据对象中数据元素之间的相互关系。 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。 图形结构：图形结构的数据元素是多对多的关系。 物理结构：是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。 结构类型：由若干类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成。 抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。 抽象数据类型的标准格式见上↑↑↑ 总结：]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java读取txt文件]]></title>
    <url>%2F2018%2F07%2F26%2Fjava%E5%BA%94%E7%94%A8%2Fjava%E8%AF%BB%E5%8F%96txt%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.HashMap;import java.util.Map;public class TXTParseUtils &#123; private static final Integer ONE = 1; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); /* 读取数据 */ try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File("111.txt")), "UTF-8")); String lineTxt = null; while ((lineTxt = br.readLine()) != null) &#123; String[] names = lineTxt.split(","); for (String name : names) &#123; if (map.keySet().contains(name)) &#123; map.put(name, (map.get(name) + ONE)); &#125; else &#123; map.put(name, ONE); &#125; &#125; &#125; br.close(); &#125; catch (Exception e) &#123; System.err.println("read errors :" + e); &#125; /* 输出数据 */ try &#123; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File("final.txt")), "UTF-8")); for (String name : map.keySet()) &#123; bw.write(name + " " + map.get(name)); bw.newLine(); &#125; bw.close(); &#125; catch (Exception e) &#123; System.err.println("write errors :" + e); &#125; &#125;&#125; 测试数据： 文苏洋,闫少翀,孟超张育铭,王洪展程浩男,路佳琦罗天实,wsy,ysc,mc,zymwhz,ljq,ltschn 运行结果： 闫少翀 1罗天实 1ysc 1whz 1chn 1王洪展 1lts 1孟超 1文苏洋 1张育铭 1程浩男 1zym 1ljq 1mc 1路佳琦 1wsy 1]]></content>
      <categories>
        <category>java</category>
        <category>java应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%85%B6%E4%BB%96%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
</search>
